/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/connector/index.js":
/*!*********************************!*\
  !*** ./dist/connector/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connector = void 0;\nconst Connector = (localName) => {\n    return (connectorTemplate) => {\n        return {\n            localName: localName,\n            attr: (connectorTemplate && connectorTemplate.attr ? connectorTemplate.attr : {}),\n            childrens: (connectorTemplate && connectorTemplate.childrens ? connectorTemplate.childrens : []),\n            proto: (connectorTemplate && connectorTemplate.proto ? connectorTemplate.proto : {})\n        };\n    };\n};\nexports.Connector = Connector;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/connector/index.js?");

/***/ }),

/***/ "./dist/controller/effects/index.js":
/*!******************************************!*\
  !*** ./dist/controller/effects/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Effects = void 0;\nconst Effects = () => {\n    return new class {\n        constructor() {\n            this.effects = new Map();\n        }\n        set(effect) {\n            let effectId = crypto.randomUUID();\n            this.effects.set(effectId, Object.assign({ id: effectId }, effect));\n            return effectId;\n        }\n        get(effectName) {\n            return Array.from([...this.effects.values()], (effect) => {\n                if (effect.name == effectName)\n                    return effect.callback;\n            })[0];\n        }\n    };\n};\nexports.Effects = Effects;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/effects/index.js?");

/***/ }),

/***/ "./dist/controller/index.js":
/*!**********************************!*\
  !*** ./dist/controller/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViewController = exports.ThoriumController = void 0;\nconst thorium_controller_1 = __webpack_require__(/*! ./thorium-controller */ \"./dist/controller/thorium-controller.js\");\nObject.defineProperty(exports, \"ThoriumController\", ({ enumerable: true, get: function () { return thorium_controller_1.ThoriumController; } }));\nconst view_controller_1 = __webpack_require__(/*! ./view-controller */ \"./dist/controller/view-controller.js\");\nObject.defineProperty(exports, \"ViewController\", ({ enumerable: true, get: function () { return view_controller_1.ViewController; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/index.js?");

/***/ }),

/***/ "./dist/controller/thorium-controller.js":
/*!***********************************************!*\
  !*** ./dist/controller/thorium-controller.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThoriumController = void 0;\nfunction ThoriumController(T) {\n    return class Controller extends T {\n        static get observedAttributes() {\n            return ['context'];\n        }\n        constructor(patern) {\n            super();\n            this.useTransaction = (transactionName) => {\n                let thorium_controller = this.$Thorium;\n                Array.from([...thorium_controller.transactions.values()], (transaction) => {\n                    if (transaction.name == transactionName) {\n                        let template = transaction.template;\n                        if (template.attr)\n                            Array.from(Object.keys(template.attr), (attributeName) => {\n                                this.setAttribute(attributeName, template.attr[attributeName]);\n                            });\n                        if (template.proto)\n                            Array.from(Object.keys(template.proto), (protoKey) => {\n                                this[protoKey] = template.proto[protoKey];\n                            });\n                    }\n                });\n            };\n            this.addTransaction = (transaction) => {\n                let transactionId = crypto.randomUUID();\n                this.$Thorium.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n                return transactionId;\n            };\n            this.removeTransaction = (transactionId) => {\n                return (this.$Thorium.transactions.has(transactionId) ? this.$Thorium.transactions.delete(transactionId) : null);\n            };\n            this.useEffect = (operationName, ...options) => {\n                let thorium_controller = this.$Thorium;\n                Array.from([...thorium_controller.effects.values()], (effect) => {\n                    if (effect.name == operationName)\n                        effect.callback(this, options);\n                });\n            };\n            this.addEffect = (effect) => {\n                let effectId = crypto.randomUUID();\n                this.$Thorium.effects.set(effectId, Object.assign({ id: effectId }, effect));\n                return effectId;\n            };\n            this.removeEffect = (effectId) => {\n                return (this.$Thorium.effects.has(effectId) ? this.$Thorium.effects.delete(effectId) : null);\n            };\n            this.patern = patern;\n        }\n        context(contextNameToFind) {\n            const findUpperElementContext = (node) => {\n                if (node.parentNode == document.body)\n                    return node;\n                if (node.attributes['context']) {\n                    if (contextNameToFind) {\n                        if (node.attributes['context'].value == contextNameToFind)\n                            return node;\n                        else\n                            return findUpperElementContext(node.parentNode);\n                    }\n                    else if (node != this) {\n                        return node;\n                    }\n                    else\n                        return findUpperElementContext(node.parentNode);\n                }\n                else\n                    return findUpperElementContext(node.parentNode);\n            };\n            return findUpperElementContext(this);\n        }\n        connectedCallback() {\n            let { transactions, transactions_onload } = this.$Thorium;\n            Array.from([...transactions_onload.values()], (transaction) => {\n                let template = transaction.template;\n                if (template.attr)\n                    Array.from(Object.keys(template.attr), (attributeName) => {\n                        if (attributeName == 'class')\n                            this.classList.add(template.attr[attributeName]);\n                        else if (attributeName == 'text')\n                            this.innerText = template.attr[attributeName];\n                        else\n                            this.setAttribute(attributeName, template.attr[attributeName]);\n                    });\n                if (template.proto)\n                    Array.from(Object.keys(template.proto), (protoKey) => {\n                        this[protoKey] = template.proto[protoKey];\n                    });\n            });\n        }\n        disconnectedCallback() {\n            if (this.onunmount)\n                this.onunmount();\n        }\n        attributeChangedCallback(name, oldValue, newValue) {\n            if (this.onmutation)\n                this.onmutation({ name, oldValue, newValue });\n            if (this.oncontextchange)\n                this.oncontextchange(newValue);\n        }\n    };\n}\nexports.ThoriumController = ThoriumController;\n//# sourceMappingURL=thorium-controller.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/thorium-controller.js?");

/***/ }),

/***/ "./dist/controller/transactions/index.js":
/*!***********************************************!*\
  !*** ./dist/controller/transactions/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transactions = void 0;\nconst Transactions = () => {\n    return new class {\n        constructor() {\n            this.transactions = new Map();\n            this.transactions_onload = new Map();\n        }\n        set(transaction) {\n            let transactionId = crypto.randomUUID();\n            this.transactions_onload.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            this.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            return transactionId;\n        }\n        add(transaction) {\n            let transactionId = crypto.randomUUID();\n            this.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            return transactionId;\n        }\n        get(transactionName) {\n        }\n    };\n};\nexports.Transactions = Transactions;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/transactions/index.js?");

/***/ }),

/***/ "./dist/controller/view-controller.js":
/*!********************************************!*\
  !*** ./dist/controller/view-controller.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViewController = void 0;\nconst dom_1 = __webpack_require__(/*! ../dom */ \"./dist/dom/index.js\");\nfunction ViewController(T) {\n    return class Controller extends T {\n        static get observedAttributes() {\n            return ['context'];\n        }\n        constructor(patern) {\n            super();\n            this.useTransaction = (transactionName) => {\n                let thorium_controller = this.$Thorium;\n                Array.from([...thorium_controller.transactions.values()], (transaction) => {\n                    if (transaction.name == transactionName) {\n                        let template = transaction.template;\n                        if (template.attr)\n                            Array.from(Object.keys(template.attr), (attributeName) => {\n                                this.setAttribute(attributeName, template.attr[attributeName]);\n                            });\n                        if (template.proto)\n                            Array.from(Object.keys(template.proto), (protoKey) => {\n                                this[protoKey] = template.proto[protoKey];\n                            });\n                    }\n                });\n            };\n            this.addTransaction = (transaction) => {\n                let transactionId = crypto.randomUUID();\n                this.$Thorium.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n                return transactionId;\n            };\n            this.removeTransaction = (transactionId) => {\n                return (this.$Thorium.transactions.has(transactionId) ? this.$Thorium.transactions.delete(transactionId) : null);\n            };\n            this.useEffect = (operationName, ...options) => {\n                let thorium_controller = this.$Thorium;\n                Array.from([...thorium_controller.effects.values()], (effect) => {\n                    if (effect.name == operationName)\n                        effect.callback(this, options);\n                });\n            };\n            this.addEffect = (effect) => {\n                let effectId = crypto.randomUUID();\n                this.$Thorium.effects.set(effectId, Object.assign({ id: effectId }, effect));\n                return effectId;\n            };\n            this.removeEffect = (effectId) => {\n                return (this.$Thorium.effects.has(effectId) ? this.$Thorium.effects.delete(effectId) : null);\n            };\n            this.patern = patern;\n            this.views = patern.views;\n        }\n        context(contextNameToFind) {\n            const findUpperElementContext = (node) => {\n                if (node.parentNode == document.body)\n                    return node;\n                if (node.attributes['context']) {\n                    if (contextNameToFind) {\n                        if (node.attributes['context'].value == contextNameToFind)\n                            return node;\n                        else\n                            return findUpperElementContext(node.parentNode);\n                    }\n                    else if (node != this) {\n                        return node;\n                    }\n                    else\n                        return findUpperElementContext(node.parentNode);\n                }\n                else\n                    return findUpperElementContext(node.parentNode);\n            };\n            return findUpperElementContext(this);\n        }\n        getContext() { return this.getAttribute('context'); }\n        getContextList() { return Object.keys(this.views); }\n        setContext(newContext) {\n            if (this.getContextList().includes(newContext))\n                this.setAttribute('context', newContext);\n            else\n                console.error(`context ${newContext} is not existing`);\n        }\n        connectedCallback() {\n            let { transactions, transactions_onload } = this.$Thorium;\n            Array.from([...transactions_onload.values()], (transaction) => {\n                let template = transaction.template;\n                if (template.attr)\n                    Array.from(Object.keys(template.attr), (attributeName) => {\n                        this.setAttribute(attributeName, template.attr[attributeName]);\n                    });\n                if (template.proto)\n                    Array.from(Object.keys(template.proto), (protoKey) => {\n                        this[protoKey] = template.proto[protoKey];\n                    });\n            });\n        }\n        disconnectedCallback() {\n            if (this.onunmount)\n                this.onunmount();\n        }\n        attributeChangedCallback(name, oldValue, newValue) {\n            let views = this.views;\n            if (this.onmutation)\n                this.onmutation({ name, oldValue, newValue });\n            if (this.oncontextchange)\n                this.oncontextchange(newValue);\n            if (views[newValue]) {\n                Array.from([...this.children].reverse(), (element) => {\n                    element.remove();\n                });\n                this.appendChild(dom_1.DOM.render(this.views[newValue]));\n            }\n            else {\n                if (oldValue) {\n                    console.error(`context ${newValue} is not existing`);\n                    this.setAttribute('context', oldValue);\n                }\n            }\n        }\n    };\n}\nexports.ViewController = ViewController;\n//# sourceMappingURL=view-controller.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/view-controller.js?");

/***/ }),

/***/ "./dist/design-system/index.js":
/*!*************************************!*\
  !*** ./dist/design-system/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst register_1 = __webpack_require__(/*! ./register */ \"./dist/design-system/register.js\");\nconst DesignSystem = () => {\n    return {\n        register: register_1.register\n    };\n};\nexports[\"default\"] = DesignSystem;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/design-system/index.js?");

/***/ }),

/***/ "./dist/design-system/register.js":
/*!****************************************!*\
  !*** ./dist/design-system/register.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.register = void 0;\nconst htmlTags = __webpack_require__(/*! html-tags */ \"./node_modules/html-tags/index.js\");\nconst dom_render_1 = __webpack_require__(/*! ../dom/dom-render */ \"./dist/dom/dom-render/index.js\");\nconst controller_1 = __webpack_require__(/*! ../controller */ \"./dist/controller/index.js\");\nconst transactions_1 = __webpack_require__(/*! ../controller/transactions */ \"./dist/controller/transactions/index.js\");\nconst effects_1 = __webpack_require__(/*! ../controller/effects */ \"./dist/controller/effects/index.js\");\nconst register = (type, patern) => {\n    var _a, _b, _c;\n    const isUnknownElement = () => {\n        return !htmlTags.includes(patern.baseName);\n    };\n    if (!isUnknownElement() && type == 'local') {\n        const constructor = document.createElement(patern.baseName).__proto__.constructor.name;\n        if (!customElements.get(`${type}-${patern.baseName}`))\n            customElements.define(`${type}-${patern.baseName}`, (_a = class extends (0, controller_1.ThoriumController)(window[constructor]) {\n                    constructor() {\n                        super();\n                        if (patern.attr)\n                            Array.from(Object.keys(patern.attr), (attributeName) => {\n                                this.setAttribute(attributeName, patern.attr[attributeName]);\n                            });\n                        if (patern.childrens) {\n                            const shadow = this.attachShadow({ mode: 'open' });\n                            Array.from(patern.childrens, (children) => {\n                                shadow.appendChild((0, dom_render_1.DOMRender)(children));\n                            });\n                        }\n                        if (patern.proto)\n                            Array.from(Object.keys(patern.proto), (protoKey) => {\n                                this[protoKey] = patern.proto[protoKey];\n                            });\n                    }\n                },\n                _a.transactions = (0, transactions_1.Transactions)(),\n                _a), { extends: patern.baseName });\n        return customElements.get(`${type}-${patern.baseName}`);\n    }\n    else {\n        if (type == 'views') {\n            if (!customElements.get(`${type}-${patern.baseName}`))\n                customElements.define(`${type}-${patern.baseName}`, (_b = class extends (0, controller_1.ViewController)(HTMLElement) {\n                        constructor() {\n                            super(patern);\n                            if (patern.attr)\n                                Array.from(Object.keys(patern.attr), (attributeName) => {\n                                    this.setAttribute(attributeName, patern.attr[attributeName]);\n                                });\n                            if (patern.childrens) {\n                                const shadow = this.attachShadow({ mode: 'open' });\n                                Array.from(patern.childrens, (children) => {\n                                    shadow.appendChild((0, dom_render_1.DOMRender)(children));\n                                });\n                            }\n                            if (patern.proto)\n                                Array.from(Object.keys(patern.proto), (protoKey) => {\n                                    this[protoKey] = patern.proto[protoKey];\n                                });\n                            let c = customElements.get(`${type}-${patern.baseName}`);\n                            let { transactions, transactions_onload } = c.transactions;\n                            let { effects } = c.effects;\n                            this.$Thorium = {\n                                transactions,\n                                transactions_onload,\n                                effects\n                            };\n                        }\n                    },\n                    _b.transactions = (0, transactions_1.Transactions)(),\n                    _b.effects = (0, effects_1.Effects)(),\n                    _b.connector = () => {\n                        return (connectorTemplate) => {\n                            return {\n                                localName: `${type}-${patern.baseName}`,\n                                attr: (connectorTemplate && connectorTemplate.attr ? connectorTemplate.attr : {}),\n                                childrens: (connectorTemplate && connectorTemplate.childrens ? connectorTemplate.childrens : []),\n                                proto: (connectorTemplate && connectorTemplate.proto ? connectorTemplate.proto : {})\n                            };\n                        };\n                    },\n                    _b));\n        }\n        else if (type == 'thorium') {\n            if (!customElements.get(`${type}-${patern.baseName}`))\n                customElements.define(`${type}-${patern.baseName}`, (_c = class extends (0, controller_1.ThoriumController)(HTMLElement) {\n                        constructor() {\n                            super(patern);\n                            if (patern.attr)\n                                Array.from(Object.keys(patern.attr), (attributeName) => {\n                                    this.setAttribute(attributeName, patern.attr[attributeName]);\n                                });\n                            if (patern.childrens) {\n                                const shadow = this.attachShadow({ mode: 'open' });\n                                Array.from(patern.childrens, (children) => {\n                                    let e = (0, dom_render_1.DOMRender)(children);\n                                    e['root'] = this;\n                                    shadow.appendChild(e);\n                                });\n                            }\n                            if (patern.proto)\n                                Array.from(Object.keys(patern.proto), (protoKey) => {\n                                    this[protoKey] = patern.proto[protoKey];\n                                });\n                            if (patern.__getter__)\n                                Array.from(Object.keys(patern.__getter__), (key) => {\n                                    Object.defineProperty(this, key, Object.assign({ get: patern.__getter__[key] }, (patern.__setter__[key] ? { set: patern.__setter__[key] } : {})));\n                                });\n                            if (patern.__setter__)\n                                Array.from(Object.keys(patern.__setter__), (key) => {\n                                    if (!this[key])\n                                        Object.defineProperty(this, key, {\n                                            set: patern.__setter__[key]\n                                        });\n                                });\n                            let c = customElements.get(`${type}-${patern.baseName}`);\n                            let { transactions, transactions_onload } = c.transactions;\n                            let { effects } = c.effects;\n                            this.$Thorium = {\n                                transactions,\n                                transactions_onload,\n                                effects\n                            };\n                        }\n                    },\n                    _c.transactions = (0, transactions_1.Transactions)(),\n                    _c.effects = (0, effects_1.Effects)(),\n                    _c.connector = () => {\n                        return (connectorTemplate) => {\n                            return {\n                                localName: `${type}-${patern.baseName}`,\n                                attr: (connectorTemplate && connectorTemplate.attr ? connectorTemplate.attr : {}),\n                                childrens: (connectorTemplate && connectorTemplate.childrens ? connectorTemplate.childrens : []),\n                                proto: (connectorTemplate && connectorTemplate.proto ? connectorTemplate.proto : {})\n                            };\n                        };\n                    },\n                    _c));\n        }\n        return customElements.get(`${type}-${patern.baseName}`);\n    }\n};\nexports.register = register;\n//# sourceMappingURL=register.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/design-system/register.js?");

/***/ }),

/***/ "./dist/dom/dom-render/index.js":
/*!**************************************!*\
  !*** ./dist/dom/dom-render/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DOMRender = void 0;\nconst DOMRender = (template) => {\n    let isLocal = (template.localName.includes('local-') ? true : false);\n    const element = (() => {\n        if (!isLocal)\n            return document.createElement(template.localName);\n        else {\n            let tag = template.localName.split('local-').filter((x) => x).join('');\n            return document.createElement(tag, { is: template.localName });\n        }\n    })();\n    if (template.attr)\n        Array.from(Object.keys(template.attr), (attributeName) => {\n            if (attributeName == 'text')\n                element.innerText = template.attr[attributeName];\n            else\n                element.setAttribute(attributeName, template.attr[attributeName]);\n        });\n    if (template.childrens)\n        Array.from(template.childrens, (childTemplate) => {\n            element.appendChild((0, exports.DOMRender)(childTemplate));\n        });\n    if (template.proto)\n        Array.from(Object.keys(template.proto), (protoKey) => {\n            element[protoKey] = template.proto[protoKey];\n        });\n    return element;\n};\nexports.DOMRender = DOMRender;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/dom-render/index.js?");

/***/ }),

/***/ "./dist/dom/dom-virtual/index.js":
/*!***************************************!*\
  !*** ./dist/dom/dom-virtual/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useEffect = exports.DOMVirtual = exports.body = exports.head = exports.htmlDocument = void 0;\nconst dom_render_1 = __webpack_require__(/*! ../dom-render */ \"./dist/dom/dom-render/index.js\");\nconst buildReferences = (element) => {\n    const virtual = {\n        reference: element,\n        get localName() { return element.tagName; },\n        get attr() {\n            return Object.fromEntries(new Map(Array.from(Object.values(Object.assign({}, element.attributes)), (attribute) => {\n                return [attribute.name, attribute.value];\n            })));\n        },\n        get children() {\n            return Array.from(element.children, (element) => {\n                return buildReferences(element);\n            });\n        },\n        attatched: [],\n        attatch: (template) => {\n            if (Array.isArray(template))\n                Array.from(template, (t) => {\n                    virtual.attatched.push(t);\n                });\n            else\n                virtual.attatched.push(template);\n            return virtual;\n        },\n        render: () => {\n            Array.from(virtual.attatched, (template) => {\n                element.appendChild((0, dom_render_1.DOMRender)(template));\n            });\n        }\n    };\n    return virtual;\n};\nconst recursiveReferenceCloning = (node, clone) => {\n    if (node.children.length > 0)\n        Array.from(node.children, (child) => {\n            let cloneELement = clone.appendChild(child.cloneNode());\n            recursiveReferenceCloning(child, cloneELement);\n        });\n    else if (node.childNodes.length > 0)\n        Array.from(node.childNodes, (child) => {\n            if (child.nodeType === child.TEXT_NODE)\n                clone.textContent = child.textContent;\n        });\n    return clone;\n};\nexports.htmlDocument = document.implementation.createHTMLDocument();\nexports.head = recursiveReferenceCloning(document.head, exports.htmlDocument.head);\nexports.body = recursiveReferenceCloning(document.body, exports.htmlDocument.body);\nexports.DOMVirtual = { htmlDocument: exports.htmlDocument };\nconst useEffect = () => {\n    const recursiveEffect = (source, virtual) => {\n        if (!Object.is(source, virtual))\n            if (!source.isEqualNode(virtual)) {\n                source.replaceWith(virtual.cloneNode(true));\n                Array.from(virtual.children, (virtualChild) => {\n                    let childNode = source.appendChild(virtualChild.cloneNode());\n                    recursiveEffect(childNode, virtualChild);\n                });\n            }\n    };\n    recursiveEffect(document.body, exports.body);\n};\nexports.useEffect = useEffect;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/dom-virtual/index.js?");

/***/ }),

/***/ "./dist/dom/index.js":
/*!***************************!*\
  !*** ./dist/dom/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DOM = void 0;\nconst dom_render_1 = __webpack_require__(/*! ./dom-render */ \"./dist/dom/dom-render/index.js\");\nconst dom_virtual_1 = __webpack_require__(/*! ./dom-virtual */ \"./dist/dom/dom-virtual/index.js\");\nexports.DOM = {\n    render: dom_render_1.DOMRender,\n    virtual: dom_virtual_1.DOMVirtual,\n    document: dom_virtual_1.htmlDocument,\n    head: dom_virtual_1.head,\n    body: dom_virtual_1.body,\n    useEffect: dom_virtual_1.useEffect\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/index.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Page_instances, _Page__component, _Page__render, _PageHandler__pages;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageHandler = exports.Page = exports.DOM = exports.ThoriumController = exports.Connector = exports.DesignSystem = void 0;\nconst route_recognizer_1 = __webpack_require__(/*! route-recognizer */ \"./node_modules/route-recognizer/dist/route-recognizer.es.js\");\nconst connector_1 = __webpack_require__(/*! ./connector */ \"./dist/connector/index.js\");\nObject.defineProperty(exports, \"Connector\", ({ enumerable: true, get: function () { return connector_1.Connector; } }));\nconst design_system_1 = __webpack_require__(/*! ./design-system */ \"./dist/design-system/index.js\");\nexports.DesignSystem = design_system_1.default;\nconst dom_1 = __webpack_require__(/*! ./dom */ \"./dist/dom/index.js\");\nObject.defineProperty(exports, \"DOM\", ({ enumerable: true, get: function () { return dom_1.DOM; } }));\nconst controller_1 = __webpack_require__(/*! ./controller */ \"./dist/controller/index.js\");\nObject.defineProperty(exports, \"ThoriumController\", ({ enumerable: true, get: function () { return controller_1.ThoriumController; } }));\nclass Page {\n    constructor(component) {\n        _Page_instances.add(this);\n        _Page__component.set(this, void 0);\n        __classPrivateFieldSet(this, _Page__component, component, \"f\");\n    }\n    show() { __classPrivateFieldGet(this, _Page_instances, \"m\", _Page__render).call(this); }\n}\nexports.Page = Page;\n_Page__component = new WeakMap(), _Page_instances = new WeakSet(), _Page__render = function _Page__render() {\n};\nclass PageHandler extends route_recognizer_1.default {\n    constructor() {\n        super(...arguments);\n        _PageHandler__pages.set(this, new Map());\n    }\n    set(pageOption) {\n        __classPrivateFieldGet(this, _PageHandler__pages, \"f\").set(pageOption.path, new Page(pageOption.component));\n        this.add([{ path: pageOption.path, handler: () => {\n                    console.log('Page Launched');\n                } }]);\n        return __classPrivateFieldGet(this, _PageHandler__pages, \"f\").get(pageOption.path);\n    }\n}\nexports.PageHandler = PageHandler;\n_PageHandler__pages = new WeakMap();\nvar Thorium;\n(function (Thorium) {\n    Thorium.router = () => { return route_recognizer_1.default; };\n    Thorium.pages = new PageHandler();\n    Thorium.on = (pathname, page) => {\n        Thorium.pages.add([{ path: pathname, handler: () => {\n                    page.Show();\n                } }]);\n    };\n    Thorium.CreatePage = (baseName, connectorTemplate) => {\n        (0, design_system_1.default)()\n            .register('page', {\n            baseName: baseName,\n            childrens: [{ localName: 'slot' }]\n        });\n        return {\n            Connector: (0, connector_1.Connector)(`page-${baseName}`),\n            Show() { document.body.appendChild(dom_1.DOM.render(this.Connector(connectorTemplate))); }\n        };\n    };\n})(Thorium || (Thorium = {}));\nexports[\"default\"] = Thorium;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/index.js?");

/***/ }),

/***/ "./node_modules/html-tags/index.js":
/*!*****************************************!*\
  !*** ./node_modules/html-tags/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./html-tags.json */ \"./node_modules/html-tags/html-tags.json\");\n\n\n//# sourceURL=webpack://thorium-core/./node_modules/html-tags/index.js?");

/***/ }),

/***/ "./node_modules/route-recognizer/dist/route-recognizer.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/route-recognizer/dist/route-recognizer.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar createObject = Object.create;\nfunction createMap() {\n    var map = createObject(null);\n    map[\"__\"] = undefined;\n    delete map[\"__\"];\n    return map;\n}\n\nvar Target = function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n};\nTarget.prototype.to = function to (target, callback) {\n    var delegate = this.delegate;\n    if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n    }\n    this.matcher.add(this.path, target);\n    if (callback) {\n        if (callback.length === 0) {\n            throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n};\nvar Matcher = function Matcher(target) {\n    this.routes = createMap();\n    this.children = createMap();\n    this.target = target;\n};\nMatcher.prototype.add = function add (path, target) {\n    this.routes[path] = target;\n};\nMatcher.prototype.addChild = function addChild (path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n    var match = generateMatch(path, matcher, delegate);\n    if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n    }\n    callback(match);\n};\nfunction generateMatch(startingPath, matcher, delegate) {\n    function match(path, callback) {\n        var fullPath = startingPath + path;\n        if (callback) {\n            callback(generateMatch(fullPath, matcher, delegate));\n        }\n        else {\n            return new Target(fullPath, matcher, delegate);\n        }\n    }\n    \n    return match;\n}\nfunction addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0; i < routeArray.length; i++) {\n        len += routeArray[i].path.length;\n    }\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n}\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n    var paths = Object.keys(routes);\n    for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n        var nested = matcher.children[path];\n        if (nested) {\n            eachRoute(routeArray, nested, callback, binding);\n        }\n        else {\n            callback.call(binding, routeArray);\n        }\n    }\n}\nvar map = function (callback, addRouteCallback) {\n    var matcher = new Matcher();\n    callback(generateMatch(\"\", matcher, this.delegate));\n    eachRoute([], matcher, function (routes) {\n        if (addRouteCallback) {\n            addRouteCallback(this, routes);\n        }\n        else {\n            this.add(routes);\n        }\n    }, this);\n};\n\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\nfunction normalizePath(path) {\n    return path.split(\"/\")\n        .map(normalizeSegment)\n        .join(\"/\");\n}\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nvar SEGMENT_RESERVED_CHARS = /%|\\//g;\nfunction normalizeSegment(segment) {\n    if (segment.length < 3 || segment.indexOf(\"%\") === -1)\n        { return segment; }\n    return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nvar PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\nfunction encodePathSegment(str) {\n    return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n\nvar escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\nvar isArray = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getParam(params, key) {\n    if (typeof params !== \"object\" || params === null) {\n        throw new Error(\"You must pass an object as the second argument to `generate`.\");\n    }\n    if (!hasOwnProperty.call(params, key)) {\n        throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n    }\n    var value = params[key];\n    var str = typeof value === \"string\" ? value : \"\" + value;\n    if (str.length === 0) {\n        throw new Error(\"You must provide a param `\" + key + \"`.\");\n    }\n    return str;\n}\nvar eachChar = [];\neachChar[0 /* Static */] = function (segment, currentState) {\n    var state = currentState;\n    var value = segment.value;\n    for (var i = 0; i < value.length; i++) {\n        var ch = value.charCodeAt(i);\n        state = state.put(ch, false, false);\n    }\n    return state;\n};\neachChar[1 /* Dynamic */] = function (_, currentState) {\n    return currentState.put(47 /* SLASH */, true, true);\n};\neachChar[2 /* Star */] = function (_, currentState) {\n    return currentState.put(-1 /* ANY */, false, true);\n};\neachChar[4 /* Epsilon */] = function (_, currentState) {\n    return currentState;\n};\nvar regex = [];\nregex[0 /* Static */] = function (segment) {\n    return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[1 /* Dynamic */] = function () {\n    return \"([^/]+)\";\n};\nregex[2 /* Star */] = function () {\n    return \"(.+)\";\n};\nregex[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar generate = [];\ngenerate[0 /* Static */] = function (segment) {\n    return segment.value;\n};\ngenerate[1 /* Dynamic */] = function (segment, params) {\n    var value = getParam(params, segment.value);\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        return encodePathSegment(value);\n    }\n    else {\n        return value;\n    }\n};\ngenerate[2 /* Star */] = function (segment, params) {\n    return getParam(params, segment.value);\n};\ngenerate[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar EmptyObject = Object.freeze({});\nvar EmptyArray = Object.freeze([]);\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments, route, types) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.length > 0 && route.charCodeAt(0) === 47 /* SLASH */) {\n        route = route.substr(1);\n    }\n    var parts = route.split(\"/\");\n    var names = undefined;\n    var shouldDecodes = undefined;\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n        var flags = 0;\n        var type = 0;\n        if (part === \"\") {\n            type = 4 /* Epsilon */;\n        }\n        else if (part.charCodeAt(0) === 58 /* COLON */) {\n            type = 1 /* Dynamic */;\n        }\n        else if (part.charCodeAt(0) === 42 /* STAR */) {\n            type = 2 /* Star */;\n        }\n        else {\n            type = 0 /* Static */;\n        }\n        flags = 2 << type;\n        if (flags & 12 /* Named */) {\n            part = part.slice(1);\n            names = names || [];\n            names.push(part);\n            shouldDecodes = shouldDecodes || [];\n            shouldDecodes.push((flags & 4 /* Decoded */) !== 0);\n        }\n        if (flags & 14 /* Counted */) {\n            types[type]++;\n        }\n        segments.push({\n            type: type,\n            value: normalizeSegment(part)\n        });\n    }\n    return {\n        names: names || EmptyArray,\n        shouldDecodes: shouldDecodes || EmptyArray,\n    };\n}\nfunction isEqualCharSpec(spec, char, negate) {\n    return spec.char === char && spec.negate === negate;\n}\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nvar State = function State(states, id, char, negate, repeat) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n};\nState.prototype.regex = function regex$1 () {\n    if (!this._regex) {\n        this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n};\nState.prototype.get = function get (char, negate) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (nextStates === null)\n        { return; }\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isEqualCharSpec(child, char, negate)) {\n                return child;\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isEqualCharSpec(child$1, char, negate)) {\n            return child$1;\n        }\n    }\n};\nState.prototype.put = function put (char, negate, repeat) {\n    var state;\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) {\n        return state;\n    }\n    // Make a new state for the character spec\n    var states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n        this.nextStates = state.id;\n    }\n    else if (isArray(this.nextStates)) {\n        this.nextStates.push(state.id);\n    }\n    else {\n        this.nextStates = [this.nextStates, state.id];\n    }\n    // Return the new state\n    return state;\n};\n// Find a list of child states matching the next character\nState.prototype.match = function match (ch) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (!nextStates)\n        { return []; }\n    var returned = [];\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isMatch(child, ch)) {\n                returned.push(child);\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isMatch(child$1, ch)) {\n            returned.push(child$1);\n        }\n    }\n    return returned;\n};\nfunction isMatch(spec, char) {\n    return spec.negate ? spec.char !== char && spec.char !== -1 /* ANY */ : spec.char === char || spec.char === -1 /* ANY */;\n}\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states) {\n    return states.sort(function (a, b) {\n        var ref = a.types || [0, 0, 0];\n        var astatics = ref[0];\n        var adynamics = ref[1];\n        var astars = ref[2];\n        var ref$1 = b.types || [0, 0, 0];\n        var bstatics = ref$1[0];\n        var bdynamics = ref$1[1];\n        var bstars = ref$1[2];\n        if (astars !== bstars) {\n            return astars - bstars;\n        }\n        if (astars) {\n            if (astatics !== bstatics) {\n                return bstatics - astatics;\n            }\n            if (adynamics !== bdynamics) {\n                return bdynamics - adynamics;\n            }\n        }\n        if (adynamics !== bdynamics) {\n            return adynamics - bdynamics;\n        }\n        if (astatics !== bstatics) {\n            return bstatics - astatics;\n        }\n        return 0;\n    });\n}\nfunction recognizeChar(states, ch) {\n    var nextStates = [];\n    for (var i = 0, l = states.length; i < l; i++) {\n        var state = states[i];\n        nextStates = nextStates.concat(state.match(ch));\n    }\n    return nextStates;\n}\nvar RecognizeResults = function RecognizeResults(queryParams) {\n    this.length = 0;\n    this.queryParams = queryParams || {};\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice = Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\nfunction findHandler(state, originalPath, queryParams) {\n    var handlers = state.handlers;\n    var regex = state.regex();\n    if (!regex || !handlers)\n        { throw new Error(\"state not initialized\"); }\n    var captures = originalPath.match(regex);\n    var currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n    result.length = handlers.length;\n    for (var i = 0; i < handlers.length; i++) {\n        var handler = handlers[i];\n        var names = handler.names;\n        var shouldDecodes = handler.shouldDecodes;\n        var params = EmptyObject;\n        var isDynamic = false;\n        if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n            for (var j = 0; j < names.length; j++) {\n                isDynamic = true;\n                var name = names[j];\n                var capture = captures && captures[currentCapture++];\n                if (params === EmptyObject) {\n                    params = {};\n                }\n                if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n                    params[name] = capture && decodeURIComponent(capture);\n                }\n                else {\n                    params[name] = capture;\n                }\n            }\n        }\n        result[i] = {\n            handler: handler.handler,\n            params: params,\n            isDynamic: isDynamic\n        };\n    }\n    return result;\n}\nfunction decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, \"%20\");\n    var result;\n    try {\n        result = decodeURIComponent(part);\n    }\n    catch (error) {\n        result = \"\";\n    }\n    return result;\n}\nvar RouteRecognizer = function RouteRecognizer() {\n    this.names = createMap();\n    var states = [];\n    var state = new State(states, 0, -1 /* ANY */, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n};\nRouteRecognizer.prototype.add = function add (routes, options) {\n    var currentState = this.rootState;\n    var pattern = \"^\";\n    var types = [0, 0, 0];\n    var handlers = new Array(routes.length);\n    var allSegments = [];\n    var isEmpty = true;\n    var j = 0;\n    for (var i = 0; i < routes.length; i++) {\n        var route = routes[i];\n        var ref = parse(allSegments, route.path, types);\n            var names = ref.names;\n            var shouldDecodes = ref.shouldDecodes;\n        // preserve j so it points to the start of newly added segments\n        for (; j < allSegments.length; j++) {\n            var segment = allSegments[j];\n            if (segment.type === 4 /* Epsilon */) {\n                continue;\n            }\n            isEmpty = false;\n            // Add a \"/\" for the new segment\n            currentState = currentState.put(47 /* SLASH */, false, false);\n            pattern += \"/\";\n            // Add a representation of the segment to the NFA and regex\n            currentState = eachChar[segment.type](segment, currentState);\n            pattern += regex[segment.type](segment);\n        }\n        handlers[i] = {\n            handler: route.handler,\n            names: names,\n            shouldDecodes: shouldDecodes\n        };\n    }\n    if (isEmpty) {\n        currentState = currentState.put(47 /* SLASH */, false, false);\n        pattern += \"/\";\n    }\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n    var name;\n    if (typeof options === \"object\" && options !== null && options.as) {\n        name = options.as;\n    }\n    if (name) {\n        // if (this.names[name]) {\n        //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n        // }\n        this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n        };\n    }\n};\nRouteRecognizer.prototype.handlersFor = function handlersFor (name) {\n    var route = this.names[name];\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var result = new Array(route.handlers.length);\n    for (var i = 0; i < route.handlers.length; i++) {\n        var handler = route.handlers[i];\n        result[i] = handler;\n    }\n    return result;\n};\nRouteRecognizer.prototype.hasRoute = function hasRoute (name) {\n    return !!this.names[name];\n};\nRouteRecognizer.prototype.generate = function generate$1 (name, params) {\n    var route = this.names[name];\n    var output = \"\";\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var segments = route.segments;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment.type === 4 /* Epsilon */) {\n            continue;\n        }\n        output += \"/\";\n        output += generate[segment.type](segment, params);\n    }\n    if (output.charAt(0) !== \"/\") {\n        output = \"/\" + output;\n    }\n    if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n    }\n    return output;\n};\nRouteRecognizer.prototype.generateQueryString = function generateQueryString (params) {\n    var pairs = [];\n    var keys = Object.keys(params);\n    keys.sort();\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = params[key];\n        if (value == null) {\n            continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                var arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n                pairs.push(arrayPair);\n            }\n        }\n        else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n        }\n    }\n    if (pairs.length === 0) {\n        return \"\";\n    }\n    return \"?\" + pairs.join(\"&\");\n};\nRouteRecognizer.prototype.parseQueryString = function parseQueryString (queryString) {\n    var pairs = queryString.split(\"&\");\n    var queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split(\"=\"), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray = false, value = (void 0);\n        if (pair.length === 1) {\n            value = \"true\";\n        }\n        else {\n            // Handle arrays\n            if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n                isArray = true;\n                key = key.slice(0, keyLength - 2);\n                if (!queryParams[key]) {\n                    queryParams[key] = [];\n                }\n            }\n            value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n        }\n        if (isArray) {\n            queryParams[key].push(value);\n        }\n        else {\n            queryParams[key] = value;\n        }\n    }\n    return queryParams;\n};\nRouteRecognizer.prototype.recognize = function recognize (path) {\n    var results;\n    var states = [this.rootState];\n    var queryParams = {};\n    var isSlashDropped = false;\n    var hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n        path = path.substr(0, hashStart);\n    }\n    var queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        queryParams = this.parseQueryString(queryString);\n    }\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    var originalPath = path;\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        path = normalizePath(path);\n    }\n    else {\n        path = decodeURI(path);\n        originalPath = decodeURI(originalPath);\n    }\n    var pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        originalPath = originalPath.substr(0, originalPath.length - 1);\n        isSlashDropped = true;\n    }\n    for (var i = 0; i < path.length; i++) {\n        states = recognizeChar(states, path.charCodeAt(i));\n        if (!states.length) {\n            break;\n        }\n    }\n    var solutions = [];\n    for (var i$1 = 0; i$1 < states.length; i$1++) {\n        if (states[i$1].handlers) {\n            solutions.push(states[i$1]);\n        }\n    }\n    states = sortSolutions(solutions);\n    var state = solutions[0];\n    if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n            originalPath = originalPath + \"/\";\n        }\n        results = findHandler(state, originalPath, queryParams);\n    }\n    return results;\n};\nRouteRecognizer.VERSION = \"0.3.4\";\n// Set to false to opt-out of encoding and decoding path segments.\n// See https://github.com/tildeio/route-recognizer/pull/55\nRouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS = true;\nRouteRecognizer.Normalizer = {\n    normalizeSegment: normalizeSegment, normalizePath: normalizePath, encodePathSegment: encodePathSegment\n};\nRouteRecognizer.prototype.map = map;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRecognizer);\n\n//# sourceMappingURL=route-recognizer.es.js.map\n\n\n//# sourceURL=webpack://thorium-core/./node_modules/route-recognizer/dist/route-recognizer.es.js?");

/***/ }),

/***/ "./test/entry-point/src/components/app-view.ts":
/*!*****************************************************!*\
  !*** ./test/entry-point/src/components/app-view.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViewApp = void 0;\nconst __1 = __webpack_require__(/*! ../../../../ */ \"./dist/index.js\");\nconst init_1 = __webpack_require__(/*! ../transactions/init */ \"./test/entry-point/src/transactions/init.ts\");\nconst button_transaction_1 = __webpack_require__(/*! ../transactions/button-transaction */ \"./test/entry-point/src/transactions/button-transaction.ts\");\nconst add_user_1 = __webpack_require__(/*! ../effects/add-user */ \"./test/entry-point/src/effects/add-user.ts\");\nconst remove_user_1 = __webpack_require__(/*! ../effects/remove-user */ \"./test/entry-point/src/effects/remove-user.ts\");\nconst ViewApp = (0, __1.DesignSystem)()\n    .register('views', {\n    baseName: 'app',\n    defaultView: 'dashboard',\n    childrens: [{ localName: 'slot' }],\n    views: {\n        'dashboard': {\n            localName: 'div',\n            attr: { name: 'dashboard', text: '/dashboard' }\n        },\n        'user': {\n            localName: 'div',\n            attr: { name: 'user', text: '/user' }\n        },\n        'test': {\n            localName: 'div',\n            attr: { name: 'user', text: '/test' }\n        }\n    }\n});\nexports.ViewApp = ViewApp;\nViewApp.transactions.add(init_1.init);\nViewApp.transactions.add(button_transaction_1.buttonTransaction);\nViewApp.effects.set(add_user_1.addUser);\nViewApp.effects.set(remove_user_1.removeUser);\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/app-view.ts?");

/***/ }),

/***/ "./test/entry-point/src/effects/add-user.ts":
/*!**************************************************!*\
  !*** ./test/entry-point/src/effects/add-user.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addUser = void 0;\nexports.addUser = {\n    name: 'add-user',\n    callback: (target, options) => {\n        alert('add-user');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/effects/add-user.ts?");

/***/ }),

/***/ "./test/entry-point/src/effects/remove-user.ts":
/*!*****************************************************!*\
  !*** ./test/entry-point/src/effects/remove-user.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeUser = void 0;\nexports.removeUser = {\n    name: 'remove-user',\n    callback: (target, options) => {\n        alert('remove-user');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/effects/remove-user.ts?");

/***/ }),

/***/ "./test/entry-point/src/index.ts":
/*!***************************************!*\
  !*** ./test/entry-point/src/index.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst __1 = __webpack_require__(/*! ../../../ */ \"./dist/index.js\");\n__webpack_require__(/*! ./components/app-view */ \"./test/entry-point/src/components/app-view.ts\");\nconst AppView = (0, __1.Connector)('views-app');\nconst ViewApp = (0, __1.DesignSystem)()\n    .register('views', {\n    baseName: 'app',\n    defaultView: 'home',\n    childrens: [{ localName: 'slot' }],\n    views: {\n        'home': {\n            localName: 'div',\n            attr: { name: 'dashboard', text: '/dashboard' }\n        }\n    }\n});\n(() => __awaiter(void 0, void 0, void 0, function* () {\n    const { document, body, head, useEffect } = __1.DOM;\n}))();\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/index.ts?");

/***/ }),

/***/ "./test/entry-point/src/transactions/button-transaction.ts":
/*!*****************************************************************!*\
  !*** ./test/entry-point/src/transactions/button-transaction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buttonTransaction = void 0;\nexports.buttonTransaction = {\n    name: 'button-transaction',\n    template: {\n        proto: {\n            onmousedown(event) {\n                let { button } = event;\n                if (button == 0)\n                    this.useEffect('add-user');\n                else if (button == 2)\n                    this.useEffect('remove-user');\n            }\n        }\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/transactions/button-transaction.ts?");

/***/ }),

/***/ "./test/entry-point/src/transactions/init.ts":
/*!***************************************************!*\
  !*** ./test/entry-point/src/transactions/init.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports.init = {\n    name: 'init-state',\n    template: {\n        proto: {\n            onmousedown: null\n        }\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/transactions/init.ts?");

/***/ }),

/***/ "./node_modules/html-tags/html-tags.json":
/*!***********************************************!*\
  !*** ./node_modules/html-tags/html-tags.json ***!
  \***********************************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"math\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"slot\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"]');\n\n//# sourceURL=webpack://thorium-core/./node_modules/html-tags/html-tags.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./test/entry-point/src/index.ts");
/******/ 	
/******/ })()
;