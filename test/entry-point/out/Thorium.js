/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/connector/index.js":
/*!*********************************!*\
  !*** ./dist/connector/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connector = void 0;\nconst Connector = (localName) => {\n    return (connectorTemplate) => {\n        return {\n            localName: localName,\n            attr: (connectorTemplate && connectorTemplate.attr ? connectorTemplate.attr : {}),\n            childrens: (connectorTemplate && connectorTemplate.childrens ? connectorTemplate.childrens : []),\n            proto: (connectorTemplate && connectorTemplate.proto ? connectorTemplate.proto : {})\n        };\n    };\n};\nexports.Connector = Connector;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/connector/index.js?");

/***/ }),

/***/ "./dist/controller/area/index.js":
/*!***************************************!*\
  !*** ./dist/controller/area/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PaternArea = void 0;\n// export const ThoriumAreaPatern = DesignSystem().register('thorium' , {\n//   baseName : 'area',\n//   childrens : [\n//     { localName : 'start' },\n//     { localName : 'slot' },\n//     { localName : 'end' }\n//   ]\n// });\nconst PaternArea = (patern) => {\n    return {\n        localName: 'thorium-area',\n        attr: (patern && patern.attr ? patern.attr : {}),\n        childrens: [\n            { localName: 'start' },\n            { localName: 'slot' },\n            ...(patern && patern.childrens ? patern.childrens : []),\n            { localName: 'end' },\n        ]\n    };\n};\nexports.PaternArea = PaternArea;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/area/index.js?");

/***/ }),

/***/ "./dist/controller/effects/index.js":
/*!******************************************!*\
  !*** ./dist/controller/effects/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Effects = void 0;\n/**\n * Fonction permettant de créer un modèle de gestion des effets utilisés par un élément personnalisé.\n *\n * @template Z - Le type de nom d'effet.\n * @returns Un objet contenant les méthodes pour gérer les effets.\n */\nconst Effects = () => {\n    return new class {\n        constructor() {\n            this.effects = new Map();\n        }\n        /**\n         * Ajoute un nouvel effet à la collection d'effets.\n         *\n         * @method set\n         * @param {IEffect} effect - L'effet à ajouter.\n         * @returns {string} L'identifiant unique de l'effet ajouté.\n        */\n        set(effect) {\n            let effectId = crypto.randomUUID();\n            this.effects.set(effectId, Object.assign({ id: effectId }, effect));\n            return effectId;\n        }\n        /**\n         * Récupère la fonction de rappel associée à un effet à partir de son nom.\n         *\n         * @method get\n         * @param {string} effectName - Le nom de l'effet à récupérer.\n         * @returns {Function} La fonction de rappel associée à l'effet, ou undefined si l'effet n'est pas trouvé.\n        */\n        get(effectName) {\n            return Array.from([...this.effects.values()], (effect) => {\n                if (effect.name == effectName)\n                    return effect.callback;\n            })[0];\n        }\n    };\n};\nexports.Effects = Effects;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/effects/index.js?");

/***/ }),

/***/ "./dist/controller/index.js":
/*!**********************************!*\
  !*** ./dist/controller/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Controller = exports.PaternArea = exports.ViewController = exports.ThoriumController = exports.PageController = void 0;\nconst page_controller_1 = __webpack_require__(/*! ./page-controller */ \"./dist/controller/page-controller.js\");\nObject.defineProperty(exports, \"PageController\", ({ enumerable: true, get: function () { return page_controller_1.PageController; } }));\nconst thorium_controller_1 = __webpack_require__(/*! ./thorium-controller */ \"./dist/controller/thorium-controller.js\");\nObject.defineProperty(exports, \"ThoriumController\", ({ enumerable: true, get: function () { return thorium_controller_1.ThoriumController; } }));\nconst view_controller_1 = __webpack_require__(/*! ./view-controller */ \"./dist/controller/view-controller.js\");\nObject.defineProperty(exports, \"ViewController\", ({ enumerable: true, get: function () { return view_controller_1.ViewController; } }));\nconst dom_1 = __webpack_require__(/*! ../dom */ \"./dist/dom/index.js\");\nconst transactions_1 = __webpack_require__(/*! ./transactions */ \"./dist/controller/transactions/index.js\");\nconst effects_1 = __webpack_require__(/*! ./effects */ \"./dist/controller/effects/index.js\");\nconst area_1 = __webpack_require__(/*! ./area */ \"./dist/controller/area/index.js\");\nObject.defineProperty(exports, \"PaternArea\", ({ enumerable: true, get: function () { return area_1.PaternArea; } }));\n/**\n * Fonction générique permettant de créer un contrôleur personnalisé pour un composant web.\n *\n * @param paternName - Le nom du modèle de design utilisé pour le composant.\n * @param patern - Le modèle de design utilisé pour le composant.\n * @param sourceClass - La classe source à partir de laquelle le contrôleur est étendu.\n * @returns La classe du contrôleur personnalisé pour le composant web.\n*/\nconst Controller = (paternName, patern, sourceClass) => {\n    var _a;\n    return _a = class Controller extends sourceClass {\n            static get observedAttributes() {\n                return [...(patern.observedAttibutes ? patern.observedAttibutes : []), 'context'];\n            }\n            constructor() {\n                super();\n                this.isMounted = false;\n                /**\n                 * Active une transaction spécifique sur le composant.\n                 *\n                 * @method useTransaction\n                 * @param transactionName - Le nom de la transaction à activer.\n                */\n                this.useTransaction = (transactionName) => {\n                    // Récupérer le contrôleur Thorium associé au composant\n                    let thorium_controller = this.$Thorium;\n                    // Parcourir toutes les transactions du contrôleur\n                    Array.from([...thorium_controller.transactions.values()], (transaction) => {\n                        // Si le nom de la transaction correspond\n                        if (transaction.name == transactionName) {\n                            let template = transaction.template;\n                            // Appliquer les attributs de modèle à l'élément\n                            if (template.attr)\n                                Array.from(Object.keys(template.attr), (attributeName) => {\n                                    this.setAttribute(attributeName, template.attr[attributeName]);\n                                });\n                            // Appliquer les variables et méthodes de modèle à l'élément\n                            if (template.proto)\n                                Array.from(Object.keys(template.proto), (protoKey) => {\n                                    this[protoKey] = template.proto[protoKey];\n                                });\n                        }\n                    });\n                };\n                /**\n                 * Ajoute une transaction au contrôleur Thorium.\n                 *\n                 * @method addTransaction\n                 * @param transaction - La transaction à ajouter.\n                 * @returns L'ID de la transaction ajoutée.\n                */\n                this.addTransaction = (transaction) => {\n                    // Générer un ID unique pour la transaction\n                    let transactionId = crypto.randomUUID();\n                    // Ajouter la transaction au contrôleur Thorium en utilisant l'ID généré\n                    this.$Thorium.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n                    // Retourner l'ID de la transaction ajoutée\n                    return transactionId;\n                };\n                /**\n                 * Supprime une transaction au contrôleur Thorium.\n                 *\n                 * @method removeTransaction\n                 * @param transactionId - L'ID de la transaction à supprimer.\n                 * @returns True si la transaction a été supprimée avec succès, sinon null.\n                */\n                this.removeTransaction = (transactionId) => {\n                    return (this.$Thorium.transactions.has(transactionId) ? this.$Thorium.transactions.delete(transactionId) : null);\n                };\n                /**\n                 * Active un effet spécifique du contrôleur Thorium.\n                 *\n                 * @method useEffect\n                 * @param operationName - Le nom de l'effet à activer.\n                 * @param options - Options supplémentaires à transmettre à l'effet.\n                */\n                this.useEffect = (operationName, ...options) => {\n                    let thorium_controller = this.$Thorium;\n                    // Parcours de tous les effets du contrôleur Thorium\n                    Array.from([...thorium_controller.effects.values()], (effect) => {\n                        if (effect.name == operationName)\n                            effect.callback(this, options);\n                    });\n                };\n                /**\n                 * Ajoute un nouvel effet au contrôleur Thorium.\n                 *\n                 * @method addEffect\n                 * @param effect - L'effet à ajouter, représenté par un objet contenant les propriétés `name` (nom de l'effet) et `callback` (fonction callback de l'effet).\n                 * @returns L'ID de l'effet ajouté.\n                */\n                this.addEffect = (effect) => {\n                    let effectId = crypto.randomUUID();\n                    this.$Thorium.effects.set(effectId, Object.assign({ id: effectId }, effect));\n                    return effectId;\n                };\n                /**\n                 * Supprime un effet du contrôleur Thorium.\n                 *\n                 * @method removeEffect\n                 * @param effectId - L'ID de l'effet à supprimer.\n                 * @returns `true` si l'effet a été supprimé avec succès, sinon `false`.\n                */\n                this.removeEffect = (effectId) => {\n                    return (this.$Thorium.effects.has(effectId) ? this.$Thorium.effects.delete(effectId) : null);\n                };\n                /**\n                 * Map contenant les observateurs pour chaque attribut.\n                 * Chaque clé de la map correspond à un nom d'attribut,\n                 * et chaque valeur est un map contenant les observateurs\n                 * associés à cet attribut.\n                */\n                this.oberservers = new Map();\n                /**\n                 * Récupère l'observateur correspondant à l'ID spécifié.\n                 *\n                 * @param observerId L'ID de l'observateur à récupérer.\n                 * @returns L'observateur correspondant à l'ID spécifié, s'il existe ; sinon, null.\n                */\n                this.getObserver = (observerId) => {\n                    return Array.from(this.oberservers.values(), (stack) => {\n                        return Array.from(stack.values(), (observerInfo) => {\n                            if (observerInfo._id == observerId)\n                                return observerInfo;\n                        });\n                    }).flat().filter((x) => x)[0];\n                };\n                /**\n                 * Supprime l'observateur correspondant à l'ID spécifié.\n                 *\n                 * @param observerId L'ID de l'observateur à supprimer.\n                 * @returns True si l'observateur a été supprimé avec succès ; sinon, false.\n                */\n                this.removeObserver = (observerId) => {\n                    return Array.from(this.oberservers.values(), (stack) => {\n                        return (stack.has(observerId) ? stack.delete(observerId) : null);\n                    }).flat().filter((x) => x)[0];\n                };\n                /**\n                 * Déclenche les rappels des observateurs en réponse à une mutation observée.\n                 *\n                 * @param mutation La mutation observée.\n                */\n                this.delegateObservedMutation = (mutation) => {\n                    let { attributeName, oldValue, newValue } = mutation;\n                    // Récupération de la pile d'observateurs correspondant à l'attribut modifié\n                    let stack = (this.oberservers.has(attributeName) ? this.oberservers.get(attributeName) : null);\n                    if (stack)\n                        Array.from(stack.values(), (observer) => {\n                            // Vérification si l'observateur a un élément source et si cet élément est toujours présent dans le document\n                            if (observer.sourceElement && document.body.contains(observer.sourceElement))\n                                observer.callback(mutation);\n                            // Si l'observateur n'a pas d'élément source, le rappel du callback est effectué\n                            else if (!observer.sourceElement)\n                                observer.callback(mutation);\n                            // Si l'observateur a un élément source mais il n'est plus présent dans le document,\n                            // il est supprimé de la pile d'observateurs\n                            else\n                                stack.delete(observer._id);\n                        });\n                };\n                /**\n                 * Ajoute un observateur pour surveiller les modifications d'attributs d'un composant tiers.\n                 * @param sourceElement L'élément personnalisé ou l'élément HTML correspondant au composant tiers.\n                 * @param event L'événement correspondant à la modification d'attribut à observer.\n                 * @param callback La fonction de rappel à appeler lorsque la modification d'attribut est détectée.\n                 * @returns L'observateur créé pour la surveillance des modifications d'attributs.\n                 * @throws Une erreur si `sourceElement` n'est pas un composant Thorium valide.\n                */\n                this.addComponentObserver = (sourceElement, event, callback) => {\n                    let patern = ('patern' in sourceElement ? sourceElement.patern : null);\n                    console.warn('sourceElement : ', sourceElement);\n                    console.warn('patern : ', patern);\n                    if (patern) {\n                        let observedAttibutes = ('observedAttibutes' in patern ? patern.observedAttibutes : null);\n                        console.warn('observedAttibutes : ', observedAttibutes, event);\n                        if (observedAttibutes.includes(event)) {\n                            return sourceElement.on(event, callback, this);\n                        }\n                    }\n                    else\n                        console.error(\"Seems that this sourceElement ins't a thorium-component\");\n                };\n                /**\n                 * Attache un observateur à un attribut spécifique d'un élément personnalisé ou d'un élément DOM.\n                 * L'observateur sera déclenché lorsqu'un changement est détecté sur l'attribut spécifié.\n                 *\n                 * @param attributeName - Le nom de l'attribut à observer.\n                 * @param callback - La fonction de rappel qui sera exécutée lorsque le changement est détecté.\n                 *                   La fonction de rappel reçoit un argument contenant des informations sur la mutation.\n                 * @param sourceElement - (Facultatif) L'élément personnalisé ou l'élément DOM à observer.\n                 *                       Si non spécifié, l'observateur sera attaché à l'élément courant.\n                 * @returns L'observateur créé, qui peut être utilisé pour le détacher ultérieurement.\n                */\n                this.on = (attributeName, callback, sourceElement) => {\n                    let stack = (this.oberservers.has(attributeName) ? this.oberservers.get(attributeName) : (() => {\n                        this.oberservers.set(attributeName, new Map());\n                        return this.oberservers.get(attributeName);\n                    })());\n                    let oberserverId = crypto.randomUUID();\n                    stack.set(oberserverId, {\n                        _id: oberserverId,\n                        attributeName: attributeName,\n                        target: this,\n                        sourceElement: sourceElement,\n                        callback: callback\n                    });\n                    return stack.get(oberserverId);\n                };\n                this.patern = patern;\n                // Création et attache de l'ombre du web component\n                if (patern.childrens) {\n                    const shadow = this.attachShadow({ mode: 'open' });\n                    Array.from(patern.childrens, (children) => {\n                        shadow.appendChild(dom_1.DOM.render(children));\n                    });\n                }\n                // Définition des getters du contrôleur\n                if (patern.__getter__ && Object.keys(patern.__getter__).length > 0) {\n                    Array.from(Object.keys(patern.__getter__), (key) => {\n                        let element = this;\n                        this.__defineGetter__(key, () => {\n                            return patern.__getter__[key](element);\n                        });\n                    });\n                }\n                // Définition des setters du contrôleur\n                if (patern.__setter__ && Object.keys(patern.__setter__).length > 0) {\n                    Array.from(Object.keys(patern.__setter__), (key) => {\n                        let element = this;\n                        this.__defineSetter__(key, (value) => {\n                            return patern.__setter__[key](value, element);\n                        });\n                    });\n                }\n                // Copie des variables et méthodes vers l'instance du controller\n                if (patern.proto)\n                    Array.from(Object.keys(patern.proto), (protoKey) => {\n                        this[protoKey] = patern.proto[protoKey];\n                    });\n                // Récupération des transactions et des effets depuis le modèle du web component\n                let c = customElements.get(paternName);\n                let { transactions, transactions_onload } = c.transactions;\n                let { effects } = c.effects;\n                let $Thorium = {\n                    transactions,\n                    get transactionList() {\n                        return Array.from([...$Thorium.transactions.keys()], (key) => {\n                            return { key: key, name: $Thorium.transactions.get(key).name };\n                        });\n                    },\n                    transactions_onload,\n                    effects,\n                    get effectList() {\n                        return Array.from([...$Thorium.effects.keys()], (key) => {\n                            return { key: key, name: $Thorium.effects.get(key).name };\n                        });\n                    },\n                };\n                this.$Thorium = $Thorium;\n                if (this.beforeMounting)\n                    this.beforeMounting();\n            }\n            /**\n             * Récupère le contexte de l'élément personnalisé.\n             *\n             * @method context\n             * @typeparam T - Le type de l'élément contextuel recherché.\n             * @param contextNameToFind - Le nom optionnel du contexte à rechercher.\n             * @returns L'élément contextuel correspondant ou `undefined` si aucun contexte n'est trouvé.\n            */\n            context(contextNameToFind) {\n                /**\n                 * Fonction récursive pour rechercher le contexte dans les éléments parents.\n                 *\n                 * @function findUpperElementContext\n                 * @param node - L'élément en cours d'examen.\n                 * @returns L'élément contextuel correspondant ou `undefined` si aucun contexte n'est trouvé.\n                */\n                const findUpperElementContext = (node) => {\n                    // Si le parentNode est body, retourner l'élément actuel\n                    if (node.parentNode == document.body)\n                        return node;\n                    // Si l'élément est un contexte\n                    if (node.attributes['context']) {\n                        // Si nous cherchons le contexte par son nom, nous comparons node.name avec contextNameToFind\n                        if (contextNameToFind) {\n                            // Si le nom correspond, retourner l'élément\n                            if (node.attributes['context'].value == contextNameToFind)\n                                return node;\n                            // Sinon, essayer de chercher dans les niveaux supérieurs\n                            else\n                                return findUpperElementContext(node.parentNode);\n                        }\n                        // Si le contexte est trouvé et que l'élément est différent de celui recherché pour son contexte, retourner l'élément\n                        else if (node != this) {\n                            return node;\n                        }\n                        // Sinon, essayer de chercher dans les niveaux supérieurs\n                        else\n                            return findUpperElementContext(node.parentNode);\n                    }\n                    // Sinon, essayer de chercher dans les niveaux supérieurs\n                    else\n                        return findUpperElementContext(node.parentNode);\n                };\n                // Appeler la fonction de recherche en commençant par l'élément actuel et la convertir en type T\n                return findUpperElementContext(this);\n            }\n            /** Gestionnaire de cycle de vie : connectedCallback */\n            connectedCallback() {\n                let { transactions, transactions_onload } = this.$Thorium;\n                // Parcours des transactions et transactions_onload définies dans le modèle du composant\n                Array.from([...transactions_onload.values()], (transaction) => {\n                    let template = transaction.template;\n                    // Application des attributs correspondant au template de la transaction\n                    if (template.attr)\n                        Array.from(Object.keys(template.attr), (attributeName) => {\n                            if (attributeName == 'class')\n                                this.classList.add(template.attr[attributeName]);\n                            else if (attributeName == 'text')\n                                this.innerText = template.attr[attributeName];\n                            else\n                                this.setAttribute(attributeName, template.attr[attributeName]);\n                        });\n                    // Application des variables et méthodes prototypes correspondant au template de la transaction\n                    if (template.proto)\n                        Array.from(Object.keys(template.proto), (protoKey) => {\n                            this[protoKey] = template.proto[protoKey];\n                        });\n                });\n                // Application des attributs déclaré dans le patern à l'élément custom\n                if (patern.attr)\n                    Array.from(Object.keys(patern.attr), (attributeName) => {\n                        this.setAttribute(attributeName, patern.attr[attributeName]);\n                    });\n                if (this.afterMounting && !this.isMounted)\n                    this.afterMounting(this);\n                if (!this.isMounted)\n                    this.isMounted = true;\n            }\n            /** Gestionnaire de cycle de vie : disconnectedCallback */\n            disconnectedCallback() {\n                if (this.onunmount)\n                    this.onunmount();\n            }\n            /** Gestionnaire de changement d'attribut observé */\n            attributeChangedCallback(name, oldValue, newValue) {\n                let mutation = { attributeName: name, oldValue, newValue };\n                if (this.onmutation)\n                    this.onmutation(mutation);\n                if (this.oncontextchange)\n                    this.oncontextchange(newValue);\n                this.delegateObservedMutation(mutation);\n            }\n        },\n        _a.transactions = (0, transactions_1.Transactions)(),\n        _a.effects = (0, effects_1.Effects)(),\n        _a.connector = () => {\n            return (connectorTemplate) => {\n                return {\n                    localName: paternName,\n                    attr: (connectorTemplate && connectorTemplate.attr ? connectorTemplate.attr : {}),\n                    childrens: (connectorTemplate && connectorTemplate.childrens ? connectorTemplate.childrens : []),\n                    proto: (connectorTemplate && connectorTemplate.proto ? connectorTemplate.proto : {})\n                };\n            };\n        },\n        _a;\n};\nexports.Controller = Controller;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/index.js?");

/***/ }),

/***/ "./dist/controller/page-controller.js":
/*!********************************************!*\
  !*** ./dist/controller/page-controller.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageController = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./dist/controller/index.js\");\nfunction PageController(paternName, patern, T) {\n    return class extends (0, _1.Controller)(paternName, patern, T) {\n        connectedCallback() {\n            if (this.parentNode.tagName == \"BODY\") {\n                let { transactions, transactions_onload } = this.$Thorium;\n                Array.from([...transactions_onload.values()], (transaction) => {\n                    let template = transaction.template;\n                    if (template.attr)\n                        Array.from(Object.keys(template.attr), (attributeName) => {\n                            if (attributeName == 'class')\n                                this.classList.add(template.attr[attributeName]);\n                            else if (attributeName == 'text')\n                                this.innerText = template.attr[attributeName];\n                            else\n                                this.setAttribute(attributeName, template.attr[attributeName]);\n                        });\n                    if (template.proto)\n                        Array.from(Object.keys(template.proto), (protoKey) => {\n                            this[protoKey] = template.proto[protoKey];\n                        });\n                });\n                if (this.afterMounting && !this.isMounted)\n                    this.afterMounting(this);\n                if (!this.isMounted)\n                    this.isMounted = true;\n            }\n            else {\n                alert('Page component have to be mounted on body');\n                this.remove();\n            }\n        }\n    };\n}\nexports.PageController = PageController;\n//# sourceMappingURL=page-controller.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/page-controller.js?");

/***/ }),

/***/ "./dist/controller/thorium-controller.js":
/*!***********************************************!*\
  !*** ./dist/controller/thorium-controller.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThoriumController = void 0;\nconst _1 = __webpack_require__(/*! . */ \"./dist/controller/index.js\");\nfunction ThoriumController(paternName, patern, T) {\n    return class extends (0, _1.Controller)(paternName, patern, T) {\n    };\n}\nexports.ThoriumController = ThoriumController;\n//# sourceMappingURL=thorium-controller.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/thorium-controller.js?");

/***/ }),

/***/ "./dist/controller/transactions/index.js":
/*!***********************************************!*\
  !*** ./dist/controller/transactions/index.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Transactions = void 0;\n/**\n * Fonction utilitaire pour créer une instance de TransactionPatern avec des transactions spécifiques de type générique X.\n *\n * @function Transactions\n * @template X - Type générique pour les noms de transactions\n * @returns {TransactionPatern<X>} Une instance de TransactionPatern avec des transactions spécifiques de type X.\n */\nconst Transactions = () => {\n    return new class {\n        constructor() {\n            this.transactions = new Map();\n            this.transactions_onload = new Map();\n        }\n        /**\n         * Ajoute une nouvelle transaction à la fois dans les transactions normales et les transactions à exécuter lors de la génération de l'élément personnalisé.\n         *\n         * @method set\n         * @param {ITransaction} transaction - La transaction à ajouter.\n         * @returns {string} L'identifiant unique de la transaction ajoutée.\n         */\n        set(transaction) {\n            let transactionId = crypto.randomUUID();\n            this.transactions_onload.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            this.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            return transactionId;\n        }\n        /**\n         * Ajoute une nouvelle transaction uniquement dans les transactions normales.\n         *\n         * @method add\n         * @param {ITransaction} transaction - La transaction à ajouter.\n         * @returns {string} L'identifiant unique de la transaction ajoutée.\n         */\n        add(transaction) {\n            let transactionId = crypto.randomUUID();\n            this.transactions.set(transactionId, Object.assign({ id: transactionId }, transaction));\n            return transactionId;\n        }\n        /**\n         * Récupère une transaction à partir de son identifiant.\n         *\n         * @method get\n         * @param {string} transactionId - L'identifiant de la transaction à récupérer.\n         */\n        get(transactionName) {\n        }\n    };\n};\nexports.Transactions = Transactions;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/transactions/index.js?");

/***/ }),

/***/ "./dist/controller/view-controller.js":
/*!********************************************!*\
  !*** ./dist/controller/view-controller.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViewController = void 0;\nconst dom_1 = __webpack_require__(/*! ../dom */ \"./dist/dom/index.js\");\nconst _1 = __webpack_require__(/*! . */ \"./dist/controller/index.js\");\nfunction ViewController(paternName, patern, T) {\n    return class extends (0, _1.Controller)(paternName, patern, T) {\n        connectedCallback() {\n            let { transactions, transactions_onload } = this.$Thorium;\n            Array.from([...transactions_onload.values()], (transaction) => {\n                let template = transaction.template;\n                if (template.attr)\n                    Array.from(Object.keys(template.attr), (attributeName) => {\n                        this.setAttribute(attributeName, template.attr[attributeName]);\n                    });\n                if (template.proto)\n                    Array.from(Object.keys(template.proto), (protoKey) => {\n                        this[protoKey] = template.proto[protoKey];\n                    });\n            });\n            if (this.afterMounting && !this.isMounted)\n                this.afterMounting(this);\n            if (!this.isMounted)\n                this.isMounted = true;\n            /// Définission des éléments HTML contnenu dans le view\n            this.patern[\"views-elements\"] = Object.fromEntries(new Map(Array.from([...this.children].reverse(), (element) => {\n                let { tagName } = element;\n                let defaultView = this.getAttribute('defaultView');\n                if (tagName == 'CONTEXT-VIEW') {\n                    let contextName = element.getAttribute('context-name');\n                    if (defaultView != contextName)\n                        element.remove();\n                    return [contextName, element];\n                }\n                else\n                    element.remove();\n            }).filter((x) => x)));\n            console.log(this.patern);\n            if (this.patern.defaultView) {\n                this.setAttribute('context', this.patern.defaultView);\n            }\n        }\n        disconnectedCallback() {\n            if (this.onunmount)\n                this.onunmount();\n        }\n        attributeChangedCallback(name, oldValue, newValue) {\n            // let slot = this.slotContainer;\n            let views = this.patern.views;\n            let viewsElemens = this.patern['views-elements'];\n            if (this.onmutation)\n                this.onmutation({ name, oldValue, newValue });\n            if (this.oncontextchange)\n                this.oncontextchange(newValue);\n            // console.log(this.views , newValue);\n            console.log({ views, viewsElemens });\n            if (views && views[newValue]) {\n                Array.from([...this.children].reverse(), (element) => {\n                    element.remove();\n                });\n                this.appendChild(dom_1.DOM.render(views[newValue]));\n            }\n            else if (viewsElemens && viewsElemens[newValue]) {\n                Array.from([...this.children].reverse(), (element) => {\n                    element.remove();\n                });\n                this.appendChild(viewsElemens[newValue]);\n            }\n            else {\n                if (oldValue) {\n                    console.error(`context ${newValue} is not existing`);\n                    this.setAttribute('context', oldValue);\n                }\n            }\n        }\n        getContext() { return this.getAttribute('context'); }\n        getContextList() {\n            return [...new Set([\n                    ...('views' in this.patern ? Object.keys(this.patern.views) : []),\n                    ...('views-elements' in this.patern ? Object.keys(this.patern['views-elements']) : []),\n                ])];\n        }\n        setContext(newContext) {\n            if (this.getContextList().includes(newContext))\n                this.setAttribute('context', newContext);\n            else\n                console.error(`context ${newContext} is not existing`);\n        }\n    };\n}\nexports.ViewController = ViewController;\n//# sourceMappingURL=view-controller.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/controller/view-controller.js?");

/***/ }),

/***/ "./dist/design-system/index.js":
/*!*************************************!*\
  !*** ./dist/design-system/index.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst register_1 = __webpack_require__(/*! ./register */ \"./dist/design-system/register.js\");\nconst DesignSystem = () => {\n    return {\n        register: register_1.register\n    };\n};\nexports[\"default\"] = DesignSystem;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/design-system/index.js?");

/***/ }),

/***/ "./dist/design-system/register.js":
/*!****************************************!*\
  !*** ./dist/design-system/register.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.register = void 0;\nconst htmlTags = __webpack_require__(/*! html-tags */ \"./node_modules/html-tags/index.js\");\nconst dom_render_1 = __webpack_require__(/*! ../dom/dom-render */ \"./dist/dom/dom-render/index.js\");\nconst controller_1 = __webpack_require__(/*! ../controller */ \"./dist/controller/index.js\");\nconst transactions_1 = __webpack_require__(/*! ../controller/transactions */ \"./dist/controller/transactions/index.js\");\n/**\n * Enregistre un composant personnalisé dans le registre des composants.\n *\n * @param type - Le type du composant personnalisé. Peut être \"page\", \"thorium\", \"local\" ou \"views\".\n * @param patern - Le modèle de conception du composant personnalisé à enregistrer.\n * @returns Le constructeur de l'élément personnalisé enregistré.\n */\nconst register = (type, patern) => {\n    var _a;\n    let paternName = `${type}-${patern.baseName}`;\n    const isUnknownElement = () => {\n        // console.log(htmlTags , template.localName);\n        return !htmlTags.includes(patern.baseName);\n    };\n    if (!isUnknownElement() && type == 'local') {\n        const constructor = document.createElement(patern.baseName).__proto__.constructor.name;\n        if (!customElements.get(paternName))\n            customElements.define(paternName, (_a = class extends (0, controller_1.ThoriumController)(paternName, patern, window[constructor]) {\n                    constructor() {\n                        super();\n                        if (patern.attr)\n                            Array.from(Object.keys(patern.attr), (attributeName) => {\n                                this.setAttribute(attributeName, patern.attr[attributeName]);\n                            });\n                        if (patern.childrens) {\n                            const shadow = this.attachShadow({ mode: 'open' });\n                            Array.from(patern.childrens, (children) => {\n                                shadow.appendChild((0, dom_render_1.DOMRender)(children));\n                            });\n                        }\n                        if (patern.proto)\n                            Array.from(Object.keys(patern.proto), (protoKey) => {\n                                this[protoKey] = patern.proto[protoKey];\n                            });\n                    }\n                },\n                _a.transactions = (0, transactions_1.Transactions)(),\n                _a), { extends: patern.baseName });\n        return customElements.get(`${type}-${patern.baseName}`);\n    }\n    else {\n        if (type == 'page' && !customElements.get(paternName))\n            customElements.define(paternName, (0, controller_1.PageController)(paternName, patern, HTMLElement));\n        if (type == 'views' && !customElements.get(paternName))\n            customElements.define(paternName, (0, controller_1.ViewController)(paternName, patern, HTMLElement));\n        else if (type == 'thorium' && !customElements.get(paternName))\n            customElements.define(paternName, (0, controller_1.ThoriumController)(paternName, patern, HTMLElement));\n        return customElements.get(paternName);\n    }\n};\nexports.register = register;\n//# sourceMappingURL=register.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/design-system/register.js?");

/***/ }),

/***/ "./dist/dom/dom-render/index.js":
/*!**************************************!*\
  !*** ./dist/dom/dom-render/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DOMRender = void 0;\n/** Allow to generate element with a template */\nconst DOMRender = (template) => {\n    let isLocal = (template && template.localName && template.localName.includes('local-') ? true : false);\n    console.log(template);\n    const element = (() => {\n        if (!isLocal)\n            return document.createElement(template.localName);\n        else {\n            let tag = template.localName.split('local-').filter((x) => x).join('');\n            return document.createElement(tag, { is: template.localName });\n        }\n    })();\n    if (template.childrens)\n        Array.from(template.childrens, (childTemplate) => {\n            let e = (0, exports.DOMRender)(childTemplate);\n            // Design patern\n            if ('connectedCallback' in e)\n                element.appendChild(e);\n            // Not Design patern\n            else {\n                (childTemplate.proto && childTemplate.proto.beforeMounting ? childTemplate.proto.beforeMounting(e) : null);\n                element.appendChild(e);\n                (childTemplate.proto && childTemplate.proto.afterMounting ? childTemplate.proto.afterMounting(e) : null);\n            }\n        });\n    if (template.proto)\n        Array.from(Object.keys(template.proto), (protoKey) => {\n            element[protoKey] = template.proto[protoKey];\n        });\n    if (template.attr)\n        Array.from(Object.keys(template.attr), (attributeName) => {\n            if (attributeName == 'text')\n                element.innerText = template.attr[attributeName];\n            else\n                element.setAttribute(attributeName, template.attr[attributeName]);\n        });\n    return element;\n};\nexports.DOMRender = DOMRender;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/dom-render/index.js?");

/***/ }),

/***/ "./dist/dom/dom-virtual/index.js":
/*!***************************************!*\
  !*** ./dist/dom/dom-virtual/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.useEffect = exports.DOMVirtual = exports.body = exports.head = exports.htmlDocument = void 0;\nconst dom_render_1 = __webpack_require__(/*! ../dom-render */ \"./dist/dom/dom-render/index.js\");\nconst buildReferences = (element) => {\n    const virtual = {\n        reference: element,\n        get localName() { return element.tagName; },\n        get attr() {\n            return Object.fromEntries(new Map(Array.from(Object.values(Object.assign({}, element.attributes)), (attribute) => {\n                return [attribute.name, attribute.value];\n            })));\n        },\n        // localName : element.tagName,\n        // attr : Object.fromEntries(new Map(Array.from(Object.values({...element.attributes}) , (attribute:any) => {\n        //   return [attribute.name , attribute.value];\n        // }))),\n        get children() {\n            return Array.from(element.children, (element) => {\n                return buildReferences(element);\n            });\n        },\n        attatched: [],\n        attatch: (template) => {\n            if (Array.isArray(template))\n                Array.from(template, (t) => {\n                    virtual.attatched.push(t);\n                });\n            else\n                virtual.attatched.push(template);\n            return virtual;\n        },\n        render: () => {\n            Array.from(virtual.attatched, (template) => {\n                element.appendChild((0, dom_render_1.DOMRender)(template));\n            });\n        }\n    };\n    return virtual;\n};\nconst recursiveReferenceCloning = (node, clone) => {\n    // let clone = node.cloneNode() as HTMLElement;\n    // if(node.innerText)clone.innerText = node.innerText;\n    if (node.children.length > 0)\n        Array.from(node.children, (child) => {\n            let cloneELement = clone.appendChild(child.cloneNode());\n            recursiveReferenceCloning(child, cloneELement);\n        });\n    else if (node.childNodes.length > 0)\n        Array.from(node.childNodes, (child) => {\n            if (child.nodeType === child.TEXT_NODE)\n                clone.textContent = child.textContent;\n        });\n    return clone;\n};\nexports.htmlDocument = document.implementation.createHTMLDocument();\nexports.head = recursiveReferenceCloning(document.head, exports.htmlDocument.head);\nexports.body = recursiveReferenceCloning(document.body, exports.htmlDocument.body);\nexports.DOMVirtual = { htmlDocument: exports.htmlDocument };\nconst useEffect = () => {\n    const recursiveEffect = (source, virtual) => {\n        if (!Object.is(source, virtual))\n            if (!source.isEqualNode(virtual)) {\n                source.replaceWith(virtual.cloneNode(true));\n                Array.from(virtual.children, (virtualChild) => {\n                    let childNode = source.appendChild(virtualChild.cloneNode());\n                    recursiveEffect(childNode, virtualChild);\n                });\n            }\n    };\n    recursiveEffect(document.body, exports.body);\n};\nexports.useEffect = useEffect;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/dom-virtual/index.js?");

/***/ }),

/***/ "./dist/dom/index.js":
/*!***************************!*\
  !*** ./dist/dom/index.js ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DOM = void 0;\nconst dom_render_1 = __webpack_require__(/*! ./dom-render */ \"./dist/dom/dom-render/index.js\");\nconst dom_virtual_1 = __webpack_require__(/*! ./dom-virtual */ \"./dist/dom/dom-virtual/index.js\");\n/**\n * # DOM\n */\nexports.DOM = {\n    render: dom_render_1.DOMRender,\n    virtual: dom_virtual_1.DOMVirtual,\n    document: dom_virtual_1.htmlDocument,\n    head: dom_virtual_1.head,\n    body: dom_virtual_1.body,\n    useEffect: dom_virtual_1.useEffect\n};\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/dom/index.js?");

/***/ }),

/***/ "./dist/index.js":
/*!***********************!*\
  !*** ./dist/index.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _Page_instances, _Page__component, _Page__render, _PageHandler__pages;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PageHandler = exports.Page = exports.DOM = exports.PaternArea = exports.ThoriumController = exports.Connector = exports.DesignSystem = void 0;\nconst route_recognizer_1 = __webpack_require__(/*! route-recognizer */ \"./node_modules/route-recognizer/dist/route-recognizer.es.js\");\n// import 'redefine-custom-elements';\nconst connector_1 = __webpack_require__(/*! ./connector */ \"./dist/connector/index.js\");\nObject.defineProperty(exports, \"Connector\", ({ enumerable: true, get: function () { return connector_1.Connector; } }));\nconst design_system_1 = __webpack_require__(/*! ./design-system */ \"./dist/design-system/index.js\");\nexports.DesignSystem = design_system_1.default;\n// import { DOMRender , NodeTemplate } from './dom/dom-render';\nconst dom_1 = __webpack_require__(/*! ./dom */ \"./dist/dom/index.js\");\nObject.defineProperty(exports, \"DOM\", ({ enumerable: true, get: function () { return dom_1.DOM; } }));\nconst controller_1 = __webpack_require__(/*! ./controller */ \"./dist/controller/index.js\");\nObject.defineProperty(exports, \"ThoriumController\", ({ enumerable: true, get: function () { return controller_1.ThoriumController; } }));\nObject.defineProperty(exports, \"PaternArea\", ({ enumerable: true, get: function () { return controller_1.PaternArea; } }));\nclass Page {\n    constructor(component) {\n        _Page_instances.add(this);\n        _Page__component.set(this, void 0);\n        __classPrivateFieldSet(this, _Page__component, component, \"f\");\n    }\n    /**\n     * Build the page\n     */\n    show() { __classPrivateFieldGet(this, _Page_instances, \"m\", _Page__render).call(this); }\n}\nexports.Page = Page;\n_Page__component = new WeakMap(), _Page_instances = new WeakSet(), _Page__render = function _Page__render() {\n};\nclass PageHandler extends route_recognizer_1.default {\n    constructor() {\n        super(...arguments);\n        _PageHandler__pages.set(this, new Map());\n        this.recognizer = new route_recognizer_1.default();\n    }\n    /**\n     * Define the endpoint of the page\n     * @param pageOption\n     * @returns\n     */\n    set(pageOption) {\n        // Ajout de la page au répertoir\n        __classPrivateFieldGet(this, _PageHandler__pages, \"f\").set(pageOption.path, new Page(pageOption.component));\n        // Ajout du path dans le gestionaire + ajout d'un point de lancement\n        this.add([{ path: pageOption.path, handler: () => {\n                    console.log('Page Launched');\n                } }]);\n        // Return la page\n        return __classPrivateFieldGet(this, _PageHandler__pages, \"f\").get(pageOption.path);\n    }\n}\nexports.PageHandler = PageHandler;\n_PageHandler__pages = new WeakMap();\nvar Thorium;\n(function (Thorium) {\n    // Distribue un routeur\n    Thorium.router = () => { return route_recognizer_1.default; };\n    // Active page\n    Thorium.Page = null;\n    // Routeur gérant les pages\n    Thorium.pages = new PageHandler();\n    Thorium.on = (pathname, page) => {\n        Thorium.pages.add([{ path: pathname, handler: () => {\n                    page.Show();\n                } }]);\n    };\n    Thorium.CreatePage = (baseName) => {\n        const page = (0, design_system_1.default)()\n            .register('page', {\n            baseName: baseName,\n            childrens: [(0, controller_1.PaternArea)()]\n        });\n        return page;\n        // return {\n        //     ...page,\n        //     Show(){ \n        //         if(!Thorium.Page){\n        //             let connector = page.connector();\n        //             Thorium.Page = DOM.render(connector(connectorTemplate));\n        //             document.body.appendChild( Thorium.Page )\n        //         }else{\n        //             console.warn('Only one page are allowed')\n        //         }\n        //     }\n        // }\n    };\n})(Thorium || (Thorium = {}));\nexports[\"default\"] = Thorium;\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://thorium-core/./dist/index.js?");

/***/ }),

/***/ "./node_modules/html-tags/index.js":
/*!*****************************************!*\
  !*** ./node_modules/html-tags/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nmodule.exports = __webpack_require__(/*! ./html-tags.json */ \"./node_modules/html-tags/html-tags.json\");\n\n\n//# sourceURL=webpack://thorium-core/./node_modules/html-tags/index.js?");

/***/ }),

/***/ "./node_modules/route-recognizer/dist/route-recognizer.es.js":
/*!*******************************************************************!*\
  !*** ./node_modules/route-recognizer/dist/route-recognizer.es.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nvar createObject = Object.create;\nfunction createMap() {\n    var map = createObject(null);\n    map[\"__\"] = undefined;\n    delete map[\"__\"];\n    return map;\n}\n\nvar Target = function Target(path, matcher, delegate) {\n    this.path = path;\n    this.matcher = matcher;\n    this.delegate = delegate;\n};\nTarget.prototype.to = function to (target, callback) {\n    var delegate = this.delegate;\n    if (delegate && delegate.willAddRoute) {\n        target = delegate.willAddRoute(this.matcher.target, target);\n    }\n    this.matcher.add(this.path, target);\n    if (callback) {\n        if (callback.length === 0) {\n            throw new Error(\"You must have an argument in the function passed to `to`\");\n        }\n        this.matcher.addChild(this.path, target, callback, this.delegate);\n    }\n};\nvar Matcher = function Matcher(target) {\n    this.routes = createMap();\n    this.children = createMap();\n    this.target = target;\n};\nMatcher.prototype.add = function add (path, target) {\n    this.routes[path] = target;\n};\nMatcher.prototype.addChild = function addChild (path, target, callback, delegate) {\n    var matcher = new Matcher(target);\n    this.children[path] = matcher;\n    var match = generateMatch(path, matcher, delegate);\n    if (delegate && delegate.contextEntered) {\n        delegate.contextEntered(target, match);\n    }\n    callback(match);\n};\nfunction generateMatch(startingPath, matcher, delegate) {\n    function match(path, callback) {\n        var fullPath = startingPath + path;\n        if (callback) {\n            callback(generateMatch(fullPath, matcher, delegate));\n        }\n        else {\n            return new Target(fullPath, matcher, delegate);\n        }\n    }\n    \n    return match;\n}\nfunction addRoute(routeArray, path, handler) {\n    var len = 0;\n    for (var i = 0; i < routeArray.length; i++) {\n        len += routeArray[i].path.length;\n    }\n    path = path.substr(len);\n    var route = { path: path, handler: handler };\n    routeArray.push(route);\n}\nfunction eachRoute(baseRoute, matcher, callback, binding) {\n    var routes = matcher.routes;\n    var paths = Object.keys(routes);\n    for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        var routeArray = baseRoute.slice();\n        addRoute(routeArray, path, routes[path]);\n        var nested = matcher.children[path];\n        if (nested) {\n            eachRoute(routeArray, nested, callback, binding);\n        }\n        else {\n            callback.call(binding, routeArray);\n        }\n    }\n}\nvar map = function (callback, addRouteCallback) {\n    var matcher = new Matcher();\n    callback(generateMatch(\"\", matcher, this.delegate));\n    eachRoute([], matcher, function (routes) {\n        if (addRouteCallback) {\n            addRouteCallback(this, routes);\n        }\n        else {\n            this.add(routes);\n        }\n    }, this);\n};\n\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\n// values that are not reserved (i.e., unicode characters, emoji, etc). The reserved\n// chars are \"/\" and \"%\".\n// Safe to call multiple times on the same path.\n// Normalizes percent-encoded values in `path` to upper-case and decodes percent-encoded\nfunction normalizePath(path) {\n    return path.split(\"/\")\n        .map(normalizeSegment)\n        .join(\"/\");\n}\n// We want to ensure the characters \"%\" and \"/\" remain in percent-encoded\n// form when normalizing paths, so replace them with their encoded form after\n// decoding the rest of the path\nvar SEGMENT_RESERVED_CHARS = /%|\\//g;\nfunction normalizeSegment(segment) {\n    if (segment.length < 3 || segment.indexOf(\"%\") === -1)\n        { return segment; }\n    return decodeURIComponent(segment).replace(SEGMENT_RESERVED_CHARS, encodeURIComponent);\n}\n// We do not want to encode these characters when generating dynamic path segments\n// See https://tools.ietf.org/html/rfc3986#section-3.3\n// sub-delims: \"!\", \"$\", \"&\", \"'\", \"(\", \")\", \"*\", \"+\", \",\", \";\", \"=\"\n// others allowed by RFC 3986: \":\", \"@\"\n//\n// First encode the entire path segment, then decode any of the encoded special chars.\n//\n// The chars \"!\", \"'\", \"(\", \")\", \"*\" do not get changed by `encodeURIComponent`,\n// so the possible encoded chars are:\n// ['%24', '%26', '%2B', '%2C', '%3B', '%3D', '%3A', '%40'].\nvar PATH_SEGMENT_ENCODINGS = /%(?:2(?:4|6|B|C)|3(?:B|D|A)|40)/g;\nfunction encodePathSegment(str) {\n    return encodeURIComponent(str).replace(PATH_SEGMENT_ENCODINGS, decodeURIComponent);\n}\n\nvar escapeRegex = /(\\/|\\.|\\*|\\+|\\?|\\||\\(|\\)|\\[|\\]|\\{|\\}|\\\\)/g;\nvar isArray = Array.isArray;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction getParam(params, key) {\n    if (typeof params !== \"object\" || params === null) {\n        throw new Error(\"You must pass an object as the second argument to `generate`.\");\n    }\n    if (!hasOwnProperty.call(params, key)) {\n        throw new Error(\"You must provide param `\" + key + \"` to `generate`.\");\n    }\n    var value = params[key];\n    var str = typeof value === \"string\" ? value : \"\" + value;\n    if (str.length === 0) {\n        throw new Error(\"You must provide a param `\" + key + \"`.\");\n    }\n    return str;\n}\nvar eachChar = [];\neachChar[0 /* Static */] = function (segment, currentState) {\n    var state = currentState;\n    var value = segment.value;\n    for (var i = 0; i < value.length; i++) {\n        var ch = value.charCodeAt(i);\n        state = state.put(ch, false, false);\n    }\n    return state;\n};\neachChar[1 /* Dynamic */] = function (_, currentState) {\n    return currentState.put(47 /* SLASH */, true, true);\n};\neachChar[2 /* Star */] = function (_, currentState) {\n    return currentState.put(-1 /* ANY */, false, true);\n};\neachChar[4 /* Epsilon */] = function (_, currentState) {\n    return currentState;\n};\nvar regex = [];\nregex[0 /* Static */] = function (segment) {\n    return segment.value.replace(escapeRegex, \"\\\\$1\");\n};\nregex[1 /* Dynamic */] = function () {\n    return \"([^/]+)\";\n};\nregex[2 /* Star */] = function () {\n    return \"(.+)\";\n};\nregex[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar generate = [];\ngenerate[0 /* Static */] = function (segment) {\n    return segment.value;\n};\ngenerate[1 /* Dynamic */] = function (segment, params) {\n    var value = getParam(params, segment.value);\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        return encodePathSegment(value);\n    }\n    else {\n        return value;\n    }\n};\ngenerate[2 /* Star */] = function (segment, params) {\n    return getParam(params, segment.value);\n};\ngenerate[4 /* Epsilon */] = function () {\n    return \"\";\n};\nvar EmptyObject = Object.freeze({});\nvar EmptyArray = Object.freeze([]);\n// The `names` will be populated with the paramter name for each dynamic/star\n// segment. `shouldDecodes` will be populated with a boolean for each dyanamic/star\n// segment, indicating whether it should be decoded during recognition.\nfunction parse(segments, route, types) {\n    // normalize route as not starting with a \"/\". Recognition will\n    // also normalize.\n    if (route.length > 0 && route.charCodeAt(0) === 47 /* SLASH */) {\n        route = route.substr(1);\n    }\n    var parts = route.split(\"/\");\n    var names = undefined;\n    var shouldDecodes = undefined;\n    for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n        var flags = 0;\n        var type = 0;\n        if (part === \"\") {\n            type = 4 /* Epsilon */;\n        }\n        else if (part.charCodeAt(0) === 58 /* COLON */) {\n            type = 1 /* Dynamic */;\n        }\n        else if (part.charCodeAt(0) === 42 /* STAR */) {\n            type = 2 /* Star */;\n        }\n        else {\n            type = 0 /* Static */;\n        }\n        flags = 2 << type;\n        if (flags & 12 /* Named */) {\n            part = part.slice(1);\n            names = names || [];\n            names.push(part);\n            shouldDecodes = shouldDecodes || [];\n            shouldDecodes.push((flags & 4 /* Decoded */) !== 0);\n        }\n        if (flags & 14 /* Counted */) {\n            types[type]++;\n        }\n        segments.push({\n            type: type,\n            value: normalizeSegment(part)\n        });\n    }\n    return {\n        names: names || EmptyArray,\n        shouldDecodes: shouldDecodes || EmptyArray,\n    };\n}\nfunction isEqualCharSpec(spec, char, negate) {\n    return spec.char === char && spec.negate === negate;\n}\n// A State has a character specification and (`charSpec`) and a list of possible\n// subsequent states (`nextStates`).\n//\n// If a State is an accepting state, it will also have several additional\n// properties:\n//\n// * `regex`: A regular expression that is used to extract parameters from paths\n//   that reached this accepting state.\n// * `handlers`: Information on how to convert the list of captures into calls\n//   to registered handlers with the specified parameters\n// * `types`: How many static, dynamic or star segments in this route. Used to\n//   decide which route to use if multiple registered routes match a path.\n//\n// Currently, State is implemented naively by looping over `nextStates` and\n// comparing a character specification against a character. A more efficient\n// implementation would use a hash of keys pointing at one or more next states.\nvar State = function State(states, id, char, negate, repeat) {\n    this.states = states;\n    this.id = id;\n    this.char = char;\n    this.negate = negate;\n    this.nextStates = repeat ? id : null;\n    this.pattern = \"\";\n    this._regex = undefined;\n    this.handlers = undefined;\n    this.types = undefined;\n};\nState.prototype.regex = function regex$1 () {\n    if (!this._regex) {\n        this._regex = new RegExp(this.pattern);\n    }\n    return this._regex;\n};\nState.prototype.get = function get (char, negate) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (nextStates === null)\n        { return; }\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isEqualCharSpec(child, char, negate)) {\n                return child;\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isEqualCharSpec(child$1, char, negate)) {\n            return child$1;\n        }\n    }\n};\nState.prototype.put = function put (char, negate, repeat) {\n    var state;\n    // If the character specification already exists in a child of the current\n    // state, just return that state.\n    if (state = this.get(char, negate)) {\n        return state;\n    }\n    // Make a new state for the character spec\n    var states = this.states;\n    state = new State(states, states.length, char, negate, repeat);\n    states[states.length] = state;\n    // Insert the new state as a child of the current state\n    if (this.nextStates == null) {\n        this.nextStates = state.id;\n    }\n    else if (isArray(this.nextStates)) {\n        this.nextStates.push(state.id);\n    }\n    else {\n        this.nextStates = [this.nextStates, state.id];\n    }\n    // Return the new state\n    return state;\n};\n// Find a list of child states matching the next character\nState.prototype.match = function match (ch) {\n        var this$1 = this;\n\n    var nextStates = this.nextStates;\n    if (!nextStates)\n        { return []; }\n    var returned = [];\n    if (isArray(nextStates)) {\n        for (var i = 0; i < nextStates.length; i++) {\n            var child = this$1.states[nextStates[i]];\n            if (isMatch(child, ch)) {\n                returned.push(child);\n            }\n        }\n    }\n    else {\n        var child$1 = this.states[nextStates];\n        if (isMatch(child$1, ch)) {\n            returned.push(child$1);\n        }\n    }\n    return returned;\n};\nfunction isMatch(spec, char) {\n    return spec.negate ? spec.char !== char && spec.char !== -1 /* ANY */ : spec.char === char || spec.char === -1 /* ANY */;\n}\n// This is a somewhat naive strategy, but should work in a lot of cases\n// A better strategy would properly resolve /posts/:id/new and /posts/edit/:id.\n//\n// This strategy generally prefers more static and less dynamic matching.\n// Specifically, it\n//\n//  * prefers fewer stars to more, then\n//  * prefers using stars for less of the match to more, then\n//  * prefers fewer dynamic segments to more, then\n//  * prefers more static segments to more\nfunction sortSolutions(states) {\n    return states.sort(function (a, b) {\n        var ref = a.types || [0, 0, 0];\n        var astatics = ref[0];\n        var adynamics = ref[1];\n        var astars = ref[2];\n        var ref$1 = b.types || [0, 0, 0];\n        var bstatics = ref$1[0];\n        var bdynamics = ref$1[1];\n        var bstars = ref$1[2];\n        if (astars !== bstars) {\n            return astars - bstars;\n        }\n        if (astars) {\n            if (astatics !== bstatics) {\n                return bstatics - astatics;\n            }\n            if (adynamics !== bdynamics) {\n                return bdynamics - adynamics;\n            }\n        }\n        if (adynamics !== bdynamics) {\n            return adynamics - bdynamics;\n        }\n        if (astatics !== bstatics) {\n            return bstatics - astatics;\n        }\n        return 0;\n    });\n}\nfunction recognizeChar(states, ch) {\n    var nextStates = [];\n    for (var i = 0, l = states.length; i < l; i++) {\n        var state = states[i];\n        nextStates = nextStates.concat(state.match(ch));\n    }\n    return nextStates;\n}\nvar RecognizeResults = function RecognizeResults(queryParams) {\n    this.length = 0;\n    this.queryParams = queryParams || {};\n};\n\nRecognizeResults.prototype.splice = Array.prototype.splice;\nRecognizeResults.prototype.slice = Array.prototype.slice;\nRecognizeResults.prototype.push = Array.prototype.push;\nfunction findHandler(state, originalPath, queryParams) {\n    var handlers = state.handlers;\n    var regex = state.regex();\n    if (!regex || !handlers)\n        { throw new Error(\"state not initialized\"); }\n    var captures = originalPath.match(regex);\n    var currentCapture = 1;\n    var result = new RecognizeResults(queryParams);\n    result.length = handlers.length;\n    for (var i = 0; i < handlers.length; i++) {\n        var handler = handlers[i];\n        var names = handler.names;\n        var shouldDecodes = handler.shouldDecodes;\n        var params = EmptyObject;\n        var isDynamic = false;\n        if (names !== EmptyArray && shouldDecodes !== EmptyArray) {\n            for (var j = 0; j < names.length; j++) {\n                isDynamic = true;\n                var name = names[j];\n                var capture = captures && captures[currentCapture++];\n                if (params === EmptyObject) {\n                    params = {};\n                }\n                if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS && shouldDecodes[j]) {\n                    params[name] = capture && decodeURIComponent(capture);\n                }\n                else {\n                    params[name] = capture;\n                }\n            }\n        }\n        result[i] = {\n            handler: handler.handler,\n            params: params,\n            isDynamic: isDynamic\n        };\n    }\n    return result;\n}\nfunction decodeQueryParamPart(part) {\n    // http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.1\n    part = part.replace(/\\+/gm, \"%20\");\n    var result;\n    try {\n        result = decodeURIComponent(part);\n    }\n    catch (error) {\n        result = \"\";\n    }\n    return result;\n}\nvar RouteRecognizer = function RouteRecognizer() {\n    this.names = createMap();\n    var states = [];\n    var state = new State(states, 0, -1 /* ANY */, true, false);\n    states[0] = state;\n    this.states = states;\n    this.rootState = state;\n};\nRouteRecognizer.prototype.add = function add (routes, options) {\n    var currentState = this.rootState;\n    var pattern = \"^\";\n    var types = [0, 0, 0];\n    var handlers = new Array(routes.length);\n    var allSegments = [];\n    var isEmpty = true;\n    var j = 0;\n    for (var i = 0; i < routes.length; i++) {\n        var route = routes[i];\n        var ref = parse(allSegments, route.path, types);\n            var names = ref.names;\n            var shouldDecodes = ref.shouldDecodes;\n        // preserve j so it points to the start of newly added segments\n        for (; j < allSegments.length; j++) {\n            var segment = allSegments[j];\n            if (segment.type === 4 /* Epsilon */) {\n                continue;\n            }\n            isEmpty = false;\n            // Add a \"/\" for the new segment\n            currentState = currentState.put(47 /* SLASH */, false, false);\n            pattern += \"/\";\n            // Add a representation of the segment to the NFA and regex\n            currentState = eachChar[segment.type](segment, currentState);\n            pattern += regex[segment.type](segment);\n        }\n        handlers[i] = {\n            handler: route.handler,\n            names: names,\n            shouldDecodes: shouldDecodes\n        };\n    }\n    if (isEmpty) {\n        currentState = currentState.put(47 /* SLASH */, false, false);\n        pattern += \"/\";\n    }\n    currentState.handlers = handlers;\n    currentState.pattern = pattern + \"$\";\n    currentState.types = types;\n    var name;\n    if (typeof options === \"object\" && options !== null && options.as) {\n        name = options.as;\n    }\n    if (name) {\n        // if (this.names[name]) {\n        //   throw new Error(\"You may not add a duplicate route named `\" + name + \"`.\");\n        // }\n        this.names[name] = {\n            segments: allSegments,\n            handlers: handlers\n        };\n    }\n};\nRouteRecognizer.prototype.handlersFor = function handlersFor (name) {\n    var route = this.names[name];\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var result = new Array(route.handlers.length);\n    for (var i = 0; i < route.handlers.length; i++) {\n        var handler = route.handlers[i];\n        result[i] = handler;\n    }\n    return result;\n};\nRouteRecognizer.prototype.hasRoute = function hasRoute (name) {\n    return !!this.names[name];\n};\nRouteRecognizer.prototype.generate = function generate$1 (name, params) {\n    var route = this.names[name];\n    var output = \"\";\n    if (!route) {\n        throw new Error(\"There is no route named \" + name);\n    }\n    var segments = route.segments;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        if (segment.type === 4 /* Epsilon */) {\n            continue;\n        }\n        output += \"/\";\n        output += generate[segment.type](segment, params);\n    }\n    if (output.charAt(0) !== \"/\") {\n        output = \"/\" + output;\n    }\n    if (params && params.queryParams) {\n        output += this.generateQueryString(params.queryParams);\n    }\n    return output;\n};\nRouteRecognizer.prototype.generateQueryString = function generateQueryString (params) {\n    var pairs = [];\n    var keys = Object.keys(params);\n    keys.sort();\n    for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var value = params[key];\n        if (value == null) {\n            continue;\n        }\n        var pair = encodeURIComponent(key);\n        if (isArray(value)) {\n            for (var j = 0; j < value.length; j++) {\n                var arrayPair = key + \"[]\" + \"=\" + encodeURIComponent(value[j]);\n                pairs.push(arrayPair);\n            }\n        }\n        else {\n            pair += \"=\" + encodeURIComponent(value);\n            pairs.push(pair);\n        }\n    }\n    if (pairs.length === 0) {\n        return \"\";\n    }\n    return \"?\" + pairs.join(\"&\");\n};\nRouteRecognizer.prototype.parseQueryString = function parseQueryString (queryString) {\n    var pairs = queryString.split(\"&\");\n    var queryParams = {};\n    for (var i = 0; i < pairs.length; i++) {\n        var pair = pairs[i].split(\"=\"), key = decodeQueryParamPart(pair[0]), keyLength = key.length, isArray = false, value = (void 0);\n        if (pair.length === 1) {\n            value = \"true\";\n        }\n        else {\n            // Handle arrays\n            if (keyLength > 2 && key.slice(keyLength - 2) === \"[]\") {\n                isArray = true;\n                key = key.slice(0, keyLength - 2);\n                if (!queryParams[key]) {\n                    queryParams[key] = [];\n                }\n            }\n            value = pair[1] ? decodeQueryParamPart(pair[1]) : \"\";\n        }\n        if (isArray) {\n            queryParams[key].push(value);\n        }\n        else {\n            queryParams[key] = value;\n        }\n    }\n    return queryParams;\n};\nRouteRecognizer.prototype.recognize = function recognize (path) {\n    var results;\n    var states = [this.rootState];\n    var queryParams = {};\n    var isSlashDropped = false;\n    var hashStart = path.indexOf(\"#\");\n    if (hashStart !== -1) {\n        path = path.substr(0, hashStart);\n    }\n    var queryStart = path.indexOf(\"?\");\n    if (queryStart !== -1) {\n        var queryString = path.substr(queryStart + 1, path.length);\n        path = path.substr(0, queryStart);\n        queryParams = this.parseQueryString(queryString);\n    }\n    if (path.charAt(0) !== \"/\") {\n        path = \"/\" + path;\n    }\n    var originalPath = path;\n    if (RouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS) {\n        path = normalizePath(path);\n    }\n    else {\n        path = decodeURI(path);\n        originalPath = decodeURI(originalPath);\n    }\n    var pathLen = path.length;\n    if (pathLen > 1 && path.charAt(pathLen - 1) === \"/\") {\n        path = path.substr(0, pathLen - 1);\n        originalPath = originalPath.substr(0, originalPath.length - 1);\n        isSlashDropped = true;\n    }\n    for (var i = 0; i < path.length; i++) {\n        states = recognizeChar(states, path.charCodeAt(i));\n        if (!states.length) {\n            break;\n        }\n    }\n    var solutions = [];\n    for (var i$1 = 0; i$1 < states.length; i$1++) {\n        if (states[i$1].handlers) {\n            solutions.push(states[i$1]);\n        }\n    }\n    states = sortSolutions(solutions);\n    var state = solutions[0];\n    if (state && state.handlers) {\n        // if a trailing slash was dropped and a star segment is the last segment\n        // specified, put the trailing slash back\n        if (isSlashDropped && state.pattern && state.pattern.slice(-5) === \"(.+)$\") {\n            originalPath = originalPath + \"/\";\n        }\n        results = findHandler(state, originalPath, queryParams);\n    }\n    return results;\n};\nRouteRecognizer.VERSION = \"0.3.4\";\n// Set to false to opt-out of encoding and decoding path segments.\n// See https://github.com/tildeio/route-recognizer/pull/55\nRouteRecognizer.ENCODE_AND_DECODE_PATH_SEGMENTS = true;\nRouteRecognizer.Normalizer = {\n    normalizeSegment: normalizeSegment, normalizePath: normalizePath, encodePathSegment: encodePathSegment\n};\nRouteRecognizer.prototype.map = map;\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RouteRecognizer);\n\n//# sourceMappingURL=route-recognizer.es.js.map\n\n\n//# sourceURL=webpack://thorium-core/./node_modules/route-recognizer/dist/route-recognizer.es.js?");

/***/ }),

/***/ "./test/entry-point/src/components/app-view.ts":
/*!*****************************************************!*\
  !*** ./test/entry-point/src/components/app-view.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ViewApp = void 0;\nconst __1 = __webpack_require__(/*! ../../../../ */ \"./dist/index.js\");\n// import { alertTransaction } from '../transactions/alert-transaction';\n// import { hoverTransaction } from '../transactions/hover-transaction';\n// import { backgroundTransaction } from '../transactions/background-transaction';\nconst init_1 = __webpack_require__(/*! ../transactions/init */ \"./test/entry-point/src/transactions/init.ts\");\nconst button_transaction_1 = __webpack_require__(/*! ../transactions/button-transaction */ \"./test/entry-point/src/transactions/button-transaction.ts\");\nconst add_user_1 = __webpack_require__(/*! ../effects/add-user */ \"./test/entry-point/src/effects/add-user.ts\");\nconst remove_user_1 = __webpack_require__(/*! ../effects/remove-user */ \"./test/entry-point/src/effects/remove-user.ts\");\nconst ViewApp = (0, __1.DesignSystem)()\n    .register('views', {\n    baseName: 'app',\n    // defaultView : 'dashboard',\n    childrens: [{ localName: 'slot' }],\n    // views : {\n    //     'dashboard' : {\n    //         localName : 'div',\n    //         attr : { name : 'dashboard' , text : '/dashboard' }\n    //     },\n    //     'user' : {\n    //         localName : 'div',\n    //         attr : { name : 'user' , text : '/user' }\n    //     },\n    //     'test' : {\n    //         localName : 'div',\n    //         attr : { name : 'user' , text : '/test' }\n    //     }\n    // }\n    // 'view-element' : {\n    // }\n});\nexports.ViewApp = ViewApp;\n// ViewApp.transactions.add(alertTransaction);\n// ViewApp.transactions.add(hoverTransaction);\n// ViewApp.transactions.add(backgroundTransaction);\nViewApp.transactions.add(init_1.init);\nViewApp.transactions.add(button_transaction_1.buttonTransaction);\nViewApp.effects.set(add_user_1.addUser);\nViewApp.effects.set(remove_user_1.removeUser);\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/app-view.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/effects/area-hovered.ts":
/*!*****************************************************************!*\
  !*** ./test/entry-point/src/components/effects/area-hovered.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AreaHovered = void 0;\nexports.AreaHovered = {\n    name: 'area-hovered',\n    callback: (element) => {\n        element.classList.add('hover');\n        element.setAttribute('area-hovered', 'true');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/effects/area-hovered.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/effects/area-selected.ts":
/*!******************************************************************!*\
  !*** ./test/entry-point/src/components/effects/area-selected.ts ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AreaSelected = void 0;\nexports.AreaSelected = {\n    name: 'area-selected',\n    callback: (element) => {\n        element.classList.add('select');\n        element.setAttribute('area-selected', 'true');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/effects/area-selected.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/effects/area-unhovered.ts":
/*!*******************************************************************!*\
  !*** ./test/entry-point/src/components/effects/area-unhovered.ts ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AreaUnHovered = void 0;\nexports.AreaUnHovered = {\n    name: 'area-unhovered',\n    callback: (element) => {\n        element.classList.remove('hover');\n        element.setAttribute('area-hovered', 'false');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/effects/area-unhovered.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/effects/area-unselected.ts":
/*!********************************************************************!*\
  !*** ./test/entry-point/src/components/effects/area-unselected.ts ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.AreaUnSelected = void 0;\nexports.AreaUnSelected = {\n    name: 'area-unselected',\n    callback: (element) => {\n        element.classList.remove('select');\n        element.setAttribute('area-selected', 'false');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/effects/area-unselected.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/thorium-input/index.ts":
/*!****************************************************************!*\
  !*** ./test/entry-point/src/components/thorium-input/index.ts ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.areaUnSelectEffect = exports.areaSelectEffect = exports.areaUnHoverEffect = exports.areHoverEffect = exports.InitInputTransaction = void 0;\nconst dist_1 = __webpack_require__(/*! ../../../../../dist */ \"./dist/index.js\");\nconst input_transaction_1 = __webpack_require__(/*! ./transactions/input-transaction */ \"./test/entry-point/src/components/thorium-input/transactions/input-transaction.ts\");\nconst area_hovered_1 = __webpack_require__(/*! ../effects/area-hovered */ \"./test/entry-point/src/components/effects/area-hovered.ts\");\nconst area_unhovered_1 = __webpack_require__(/*! ../effects/area-unhovered */ \"./test/entry-point/src/components/effects/area-unhovered.ts\");\nconst area_selected_1 = __webpack_require__(/*! ../effects/area-selected */ \"./test/entry-point/src/components/effects/area-selected.ts\");\nconst area_unselected_1 = __webpack_require__(/*! ../effects/area-unselected */ \"./test/entry-point/src/components/effects/area-unselected.ts\");\nconst ThoriumInput = (0, dist_1.DesignSystem)()\n    .register('thorium', {\n    baseName: 'input',\n    observedAttibutes: ['loading'],\n    childrens: [(0, dist_1.PaternArea)({ childrens: [{ localName: 'input' }] })],\n    // Ajout de getters au component\n    __getter__: {\n        ['child-area']: function () { return this.shadowRoot.children[0]; },\n        ['child-start']: function () { return this['child-area'].children[0]; },\n        ['child-slot']: function () { return this['child-area'].children[1]; },\n        ['child-input']: function () { return this['child-area'].children[2]; },\n        ['child-end']: function () { return this['child-area'].children[3]; },\n        value: function () { return this['child-input'].value; },\n    },\n    // Ajout de setters au component\n    __setter__: {\n        value: function (value) { this['child-input'].value = value; }\n    }\n});\n/** Transaction pour mettre en place l'initialisation de l'input  */\nexports.InitInputTransaction = ThoriumInput.transactions.set(input_transaction_1.InitInput);\n/** Effect qui ajoute l'attribut area-hovered et la class hover */\nexports.areHoverEffect = ThoriumInput.effects.set(area_hovered_1.AreaHovered);\n/** Effect qui retire l'attribut area-hovered et la class hover */\nexports.areaUnHoverEffect = ThoriumInput.effects.set(area_unhovered_1.AreaUnHovered);\n/** Effect qui ajoute l'attribut area-selected et la class select */\nexports.areaSelectEffect = ThoriumInput.effects.set(area_selected_1.AreaSelected);\n/** Effect qui retire l'attribut area-selected et la class select */\nexports.areaUnSelectEffect = ThoriumInput.effects.set(area_unselected_1.AreaUnSelected);\nexports[\"default\"] = (() => { return ThoriumInput.connector(); })();\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/thorium-input/index.ts?");

/***/ }),

/***/ "./test/entry-point/src/components/thorium-input/transactions/input-transaction.ts":
/*!*****************************************************************************************!*\
  !*** ./test/entry-point/src/components/thorium-input/transactions/input-transaction.ts ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InitInput = void 0;\nexports.InitInput = {\n    name: 'init-input-transaction',\n    template: {\n        attr: {\n            'area-hovered': 'false',\n            'area-selected': 'false',\n        }\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/components/thorium-input/transactions/input-transaction.ts?");

/***/ }),

/***/ "./test/entry-point/src/effects/add-user.ts":
/*!**************************************************!*\
  !*** ./test/entry-point/src/effects/add-user.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addUser = void 0;\nexports.addUser = {\n    name: 'add-user',\n    callback: (target, options) => {\n        alert('add-user');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/effects/add-user.ts?");

/***/ }),

/***/ "./test/entry-point/src/effects/remove-user.ts":
/*!*****************************************************!*\
  !*** ./test/entry-point/src/effects/remove-user.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.removeUser = void 0;\nexports.removeUser = {\n    name: 'remove-user',\n    callback: (target, options) => {\n        alert('remove-user');\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/effects/remove-user.ts?");

/***/ }),

/***/ "./test/entry-point/src/index.ts":
/*!***************************************!*\
  !*** ./test/entry-point/src/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst __1 = __webpack_require__(/*! ../../../ */ \"./dist/index.js\");\n__webpack_require__(/*! ./components/app-view */ \"./test/entry-point/src/components/app-view.ts\");\nconst thorium_input_1 = __webpack_require__(/*! ./components/thorium-input */ \"./test/entry-point/src/components/thorium-input/index.ts\");\n// const ViewApp = DesignSystem()\n// .register('views' , {\n//     baseName : 'app',\n//     defaultView : 'home',\n//     childrens : [{localName : 'slot'}],\n//     views : {\n//         'home' : {\n//             localName : 'div',\n//             attr : { name : 'dashboard' , text : '/dashboard' }\n//         }\n//     }\n// });\n// const AppView = Connector('views-app');\n/**\n * Description : Comment créer un Custom Element ?\n ```typescript\n    // SANS TRANSACTION &/OU EFFECTS\n    type MyElement = CustomElement<HTMLElement , {...}>\n    // AVEC TRANSACTION &/OU EFFECTS\n    type MyElement = CustomElement<HTMLElement , {...} , Transactions , Effects>\n ```\n*/\n(() => {\n    // const { document , body , head , useEffect } = DOM;\n    window.onload = () => {\n        let element = __1.DOM.render((0, thorium_input_1.default)({\n            attr: { loading: 'false' },\n            childrens: [\n                { localName: 'label', attr: { text: 'lol : ' } }\n            ]\n        }));\n        element.afterMounting = (target) => {\n            // alert('hello');\n        };\n        document.body.appendChild(element);\n        console.log(document.body, element);\n        console.log(document.body.appendChild(element));\n    };\n    // Thorium.on('/' , AppPage);\n    // AppPage.Show();\n    // document.body.appendChild( DOMRender( Container({\n    //     attr : { context : 'container' },\n    //     childrens : [\n    //         ThoriumButton({attr : { text : 'submit' }}),\n    //         LocalButton({attr : { text : 'submit' }}),\n    //         { localName : 'button' , attr : { text : 'submit 2' , is : 'thorium-button' } }\n    //     ],\n    //     proto : {\n    //         oncontextchange : (newContext:string) => {\n    //             alert(`changement de context : ${newContext}`)\n    //         }\n    //     }\n    // }) ) )\n    // document.body.appendChild( DOM.render( AppView({\n    //     attr : { context : 'dashboard' }\n    // }) ) )\n    // useEffect();\n    // let {render} = DOM.virtual.body.attatch( \n    //     [\n    //         AppView({\n    //             attr : { context : 'dashboard' }\n    //         }),\n    //         AppView({\n    //             attr : { context : 'user' }\n    //         })\n    //     ]\n    // )\n    // // console.log(virtualElement)\n    // console.log(ViewApp)\n    // render();\n})();\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/index.ts?");

/***/ }),

/***/ "./test/entry-point/src/transactions/button-transaction.ts":
/*!*****************************************************************!*\
  !*** ./test/entry-point/src/transactions/button-transaction.ts ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.buttonTransaction = void 0;\nexports.buttonTransaction = {\n    name: 'button-transaction',\n    template: {\n        proto: {\n            onmousedown(event) {\n                let { button } = event;\n                if (button == 0)\n                    this.useEffect('add-user');\n                else if (button == 2)\n                    this.useEffect('remove-user');\n            }\n        }\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/transactions/button-transaction.ts?");

/***/ }),

/***/ "./test/entry-point/src/transactions/init.ts":
/*!***************************************************!*\
  !*** ./test/entry-point/src/transactions/init.ts ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.init = void 0;\nexports.init = {\n    name: 'init-state',\n    template: {\n        proto: {\n            onmousedown: null\n        }\n    }\n};\n\n\n//# sourceURL=webpack://thorium-core/./test/entry-point/src/transactions/init.ts?");

/***/ }),

/***/ "./node_modules/html-tags/html-tags.json":
/*!***********************************************!*\
  !*** ./node_modules/html-tags/html-tags.json ***!
  \***********************************************/
/***/ ((module) => {

eval("module.exports = JSON.parse('[\"a\",\"abbr\",\"address\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"bdi\",\"bdo\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"cite\",\"code\",\"col\",\"colgroup\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"div\",\"dl\",\"dt\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"footer\",\"form\",\"h1\",\"h2\",\"h3\",\"h4\",\"h5\",\"h6\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"img\",\"input\",\"ins\",\"kbd\",\"label\",\"legend\",\"li\",\"link\",\"main\",\"map\",\"mark\",\"math\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"nav\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"slot\",\"small\",\"source\",\"span\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"u\",\"ul\",\"var\",\"video\",\"wbr\"]');\n\n//# sourceURL=webpack://thorium-core/./node_modules/html-tags/html-tags.json?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./test/entry-point/src/index.ts");
/******/ 	
/******/ })()
;